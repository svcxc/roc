app [makeGlue] { pf: platform "../platform/main.roc" }

import pf.Types exposing [Types]
import pf.Shape exposing [RocStructFields]
import pf.File exposing [File]
import pf.TypeId exposing [TypeId]
import "../static/Cargo.toml" as rocAppCargoToml : Str
import "../../roc_std/Cargo.toml" as rocStdCargoToml : Str
import "../../roc_std/src/lib.rs" as rocStdLib : Str
import "../../roc_std/src/roc_box.rs" as rocStdBox : Str
import "../../roc_std/src/roc_list.rs" as rocStdList : Str
import "../../roc_std/src/roc_str.rs" as rocStdStr : Str
import "../../roc_std/src/storage.rs" as rocStdStorage : Str

makeGlue : List Types -> Result (List File) Str
makeGlue = \typesByArch ->
    archFiles = typesByArch |> List.map generateArchFile
    debugFile = { name: "debug.txt", content: Inspect.toStr typesByArch }
    modFile = { name: "roc_app/src/lib.rs", content: modFileContent typesByArch }

    archFiles
    |> List.append modFile
    |> List.append debugFile
    |> List.concat staticFiles
    |> Ok

modFileContent = \typesByArch ->
    List.walk typesByArch fileHeader \content, types ->
        archStr =
            types
            |> Types.target
            |> .architecture
            |> archName

        Str.concat
            content
            """
            #[cfg(target_arch = "$(archStr)")]
            mod $(archStr);
            #[cfg(target_arch = "$(archStr)")]
            pub use $(archStr)::*;


            """

fileHeader =
    """
    // ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

    #![allow(unused_unsafe)]
    #![allow(dead_code)]
    #![allow(unused_mut)]
    #![allow(non_snake_case)]
    #![allow(non_camel_case_types)]
    #![allow(non_upper_case_globals)]
    #![allow(clippy::undocumented_unsafe_blocks)]
    #![allow(clippy::redundant_static_lifetimes)]
    #![allow(clippy::unused_unit)]
    #![allow(clippy::let_and_return)]
    #![allow(clippy::needless_borrow)]
    #![allow(clippy::clone_on_copy)]
    #![allow(clippy::non_canonical_partial_ord_impl)]

    use roc_std::RocRefcounted;
    use roc_std::roc_refcounted_noop_impl;


    """

## These are always included, and don't depend on the specifics of the app.
staticFiles : List File
staticFiles = [
    { name: "roc_app/Cargo.toml", content: rocAppCargoToml },
    { name: "roc_std/Cargo.toml", content: rocStdCargoToml },
    { name: "roc_std/src/lib.rs", content: rocStdLib },
    { name: "roc_std/src/roc_box.rs", content: rocStdBox },
    { name: "roc_std/src/roc_list.rs", content: rocStdList },
    { name: "roc_std/src/roc_str.rs", content: rocStdStr },
    { name: "roc_std/src/storage.rs", content: rocStdStorage },
]

generateArchFile : Types -> File
generateArchFile = \types ->
    content =
        List.concat (typesToTlds types) (entrypoints types)
        |> List.map generateTld
        |> Str.joinWith "\n\n"
        |> Str.withPrefix fileHeader

    archStr =
        types
        |> Types.target
        |> .architecture
        |> archName

    {
        name: "roc_app/src/$(archStr).rs",
        content,
    }

archName = \arch ->
    when arch is
        Aarch32 -> "arm"
        Aarch64 -> "aarch64"
        Wasm32 -> "wasm32"
        X86x32 -> "x86"
        X86x64 -> "x86_64"

supportedTraits : Types, TypeId -> Set Trait
supportedTraits = \types, type ->
    traitsHelper = \id -> supportedTraits types id

    fieldsHelper = \fields, allowed ->
        fields
        |> List.map \{ id } -> traitsHelper id
        |> List.walk allowed Set.intersection

    tagsHelper = \tags, allowed ->
        tags
        |> List.keepOks \{ payload } ->
            when payload is
                Some id -> Ok (traitsHelper id)
                None -> Err NoPayload
        |> List.walk allowed Set.intersection

    when Types.shape types type is
        Num F32 | Num F64 ->
            Set.fromList [Clone, Copy, Default, PartialEq, PartialOrd, Debug]

        Num _ | Bool | Unit ->
            Set.fromList [Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash, Debug]

        TagUnion (Enumeration _) ->
            Set.fromList [Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug]

        RocStr ->
            Set.fromList [Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash, Debug]

        RocList a ->
            Set.fromList [Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug]
            |> Set.intersection (traitsHelper a)
            |> Set.insert Default # Default returns `[]`, so `a` need not implement Default

        RocResult ok err ->
            Set.fromList [Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug]
            |> Set.intersection (traitsHelper ok)
            |> Set.intersection (traitsHelper err)

        RocBox a ->
            Set.fromList [PartialEq, Eq, PartialOrd, Ord, Hash, Debug]
            |> Set.intersection (traitsHelper a)
            |> Set.insert Clone # Clone clones the pointer, not the value
            |> Set.insert Hash # Hash hashes the pointer, not the value

        RocDict _ _ ->
            crash "Dict is not yet implemented in roc_std"

        RocSet _ ->
            crash "Set is not yet implemented in roc_std"

        Unsized ->
            # TODO: is this correct?
            # thusfar I've only seen `Unsized` be used as the type
            # referenced as the lambdaset in a `Function`
            # and the derivable traits of a `Function` don't depend on this
            # so this should be empty I think?
            Set.empty {}

        EmptyTagUnion ->
            crash "this should probably be made to never happen"

        Function _
        | Struct { fields: HasClosure _ }
        | TagUnionPayload { fields: HasClosure _ }
        | TagUnion (SingleTagStruct { payload: HasClosure _ }) ->
            Set.single Debug

        Struct { fields: HasNoClosure fields } ->
            allowed = Set.fromList [Clone, Copy, Default, PartialOrd, Ord, PartialEq, Eq, Hash, Debug]
            fieldsHelper fields allowed

        TagUnionPayload { fields: HasNoClosure fields } ->
            allowed = Set.fromList [Clone, Copy, Default, PartialEq, Eq, Hash, Debug]
            fieldsHelper fields allowed

        TagUnion (SingleTagStruct { payload: HasNoClosure fields }) ->
            allowed = Set.fromList [Clone, Copy, Default, PartialEq, Eq, Hash, Debug]
            fieldsHelper fields allowed

        TagUnion (NonRecursive { tags }) ->
            allowed = Set.fromList [Clone, Copy, PartialEq, Eq, Hash, Debug]
            tagsHelper tags allowed

        # the `{ tags: tags } situation is due to https://github.com/roc-lang/roc/issues/7167
        TagUnion (Recursive { tags: tags })
        | TagUnion (NullableWrapped { tags: tags }) ->
            allowed = Set.fromList [Clone, PartialEq, Eq, Hash, Debug]
            tagsHelper tags allowed

        TagUnion (NonNullableUnwrapped { payload })
        | TagUnion (NullableUnwrapped { nonNullPayload: payload }) ->
            Set.fromList [Clone, PartialEq, Eq, Hash, Debug]
            |> Set.intersection (traitsHelper payload)

        RecursivePointer _ ->
            # TODO: is this correct?
            # encountering a RecursivePointer means we should have already
            # encountered the thing it's pointing to
            # so it wouldn't disqualify it from anything a recursive tag union
            # isn't already disqualified from
            Set.fromList [Clone, PartialEq, Eq, Hash, Debug]

Symbol : Str
RustType : Str

StructFields : List { name : Symbol, type : RustType }
TagUnionVariants : List { tag : Symbol, payload : RustType }

Trait : [
    Clone,
    Copy,
    Default,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    Debug,
]

Tld : [
    EntryPoint
        {
            name : Symbol,
            args : List RustType,
            result : RustType,
        },
    RecordStructDef
        {
            name : Symbol,
            fields : StructFields,
            derives : Set Trait,
        },
    RefcountImpl
        {
            name : Symbol,
            kind : [
                Noop,
                Struct { fields : List Symbol },
            ],
        },
    EnumerationEnumDef
        {
            name : Symbol,
            tags : List Symbol,
            repr : RustType,
            derives : Set Trait,
        },
    EnumerationDebugImpl
        {
            name : Symbol,
            tags : List Symbol,
        },
    PayloadUnionDef
        {
            name : Symbol,
            variants : TagUnionVariants,
        },
    NonRecTagUnionDef
        {
            name : Symbol,
            payload : RustType,
            discriminant : RustType,
            discriminantOffset : U32,
            derives : Set Trait,
        },
    RustNonRecTagUnionDef
        {
            name : Symbol,
            variants : TagUnionVariants,
            payload : RustType,
            discriminant : RustType,
            derives : Set Trait,
        },
    NonRecTagUnionConversionImpls
        {
            rocType : RustType,
            rustType : RustType,
            discriminant : RustType,
            union : RustType,
        },
    NonRecTagUnionDebugImpl
        {
            name : Symbol,
            variants : TagUnionVariants
        },
    NonRecTagUnionDebugImpl
        {

        }
]

entrypoints : Types -> List Tld
entrypoints = \types ->
    types
    |> Types.entryPoints
    |> List.map \T name type ->
        (args, result) =
            when Types.shape types type is
                Function { args: args2, ret } ->
                    (
                        List.map args2 \arg -> rustTypeName types arg,
                        rustTypeName types ret,
                    )

                _ -> ([], rustTypeName types type)

        EntryPoint { name, args, result }

typesToTlds : Types -> List Tld
typesToTlds = \types ->
    types
    |> Types.mapShapes \_, type -> typeToTlds types type
    |> List.join

typeToTlds : Types, TypeId -> List Tld
typeToTlds = \types, type ->
    shape = Types.shape types type
    when shape is
        Struct { fields } ->
            structTlds types type fields

        TagUnion (Enumeration { name, tags, size }) ->
            enumerationTlds types type (escape name) tags size

        TagUnion (NonRecursive { name, tags, discriminantSize, discriminantOffset }) ->
            nonRecTlds types type (escape name) tags discriminantSize discriminantOffset

        Function { isToplevel } if isToplevel ->
            # taken care of by `entrypoints`
            []

        Unit
        | Unsized
        | EmptyTagUnion
        | Num _
        | Bool
        | RocResult _ _
        | RocStr
        | RocDict _ _
        | RocSet _
        | RocList _
        | RocBox _ ->
            # these are taken care of by the Roc std library
            # or represented as Rust builtins
            []

        _ -> crash "todo: $(Inspect.toStr shape)"

structTlds : Types, TypeId, RocStructFields -> List Tld
structTlds = \types, type, fieldData ->
    recordName = rustTypeName types type

    traits = supportedTraits types type

    getFields = \fields ->
        List.map fields \{ name, id } ->
            { name, type: rustTypeName types id }

    rustRecordFields =
        when fieldData is
            HasNoClosure fieldList -> getFields fieldList
            HasClosure fieldList -> getFields fieldList

    structDef : Tld
    structDef =
        RecordStructDef {
            name: recordName,
            fields: rustRecordFields,
            derives: traits,
        }

    refcountImplKind =
        if Set.contains traits Copy then
            Noop
        else
            fieldNames = rustRecordFields |> List.map .name
            Struct { fields: fieldNames }

    refcountImpl : Tld
    refcountImpl =
        RefcountImpl {
            name: recordName,
            kind: refcountImplKind,
        }

    [structDef, refcountImpl]

discriminantRepr : U32 -> RustType
discriminantRepr = \bytes ->
    when bytes is
        0 -> crash "this is definitely a bug!"
        1 -> "u8"
        2 -> "u16"
        3 | 4 -> "u32"
        5 | 6 | 7 | 8 -> "u64"
        _ -> crash "this is probably a bug!"

enumerationTlds : Types, TypeId, RustType, List Str, U32 -> List Tld
enumerationTlds = \types, type, name, tags, reprBytes ->
    derives =
        supportedTraits types type
        |> Set.remove Debug # since we implement this manually

    repr = discriminantRepr reprBytes

    [
        EnumerationEnumDef { name, tags, repr, derives },
        EnumerationDebugImpl { name, tags },
        RefcountImpl { name, kind: Noop },
    ]

nonRecTlds : Types, TypeId, Str, List { name : Str, payload : [Some TypeId, None] }, U32, U32 -> List Tld
nonRecTlds = \types, type, rocName, variants, discriminantSize, discriminantOffset ->
    discriminantName = "discriminant_$(rocName)"
    unionName = "union_$(rocName)"
    enumName = "enum_$(rocName)"

    tagUnionName = escape rocName

    tags = List.map variants .name

    rustUnionVariants =
        List.map variants \{ name, payload } ->
            payloadType =
                when payload is
                    Some id -> rustTypeName types id
                    None -> "()"

            { tag: name, payload: payloadType }
    
    unionVariants =
        List.map variants \{ name, payload } ->
            payloadType =
                when payload is
                    Some id ->
                        payloadStr = rustTypeName types id
                        if
                            supportedTraits types id
                            |> Set.contains Copy
                        then
                            "core::mem::ManuallyDrop<$(payloadStr)>"
                        else
                            payloadStr
                        
                    None -> "()"

            { tag: name, payload: payloadType }
    
    # nonCopyVariants =


    allowedTraits = supportedTraits types type

    tagUnionDerives =
        # removing the ones we manually implement (if they're supported at all)
        allowedTraits
        |> Set.remove PartialEq # TODO: implement manually
        |> Set.remove Eq # TODO: implement manually
        |> Set.remove Hash # TODO: implement manually
        |> Set.remove Debug

    enumerationTlds types type discriminantName tags discriminantSize
    |> List.concat [
        PayloadUnionDef {
            name: unionName,
            variants: unionVariants,
        },
        NonRecTagUnionDef {
            name: tagUnionName,
            payload: unionName,
            discriminant: discriminantName,
            discriminantOffset,
            derives: tagUnionDerives,
        },
        RustNonRecTagUnionDef {
            name: enumName,
            payload: unionName,
            variants: rustEnumVariants,
            discriminant: discriminantName,
            derives: allowedTraits,
        },
        NonRecTagUnionConversionImpls {
            rocType: tagUnionName,
            rustType: enumName,
            discriminant: discriminantName,
            union: unionName,
        },
        NonRecTagUnionDebugImpl {
            
        }
    ]
    |> List.appendIfOk (
        if Set.contains allowedTraits Hash then
            
            |> Ok
        else
            Err NotEligable
    )

reservedKeywords = Set.fromList [
    "try",
    "abstract",
    "become",
    "box",
    "do",
    "final",
    "macro",
    "override",
    "priv",
    "typeof",
    "unsized",
    "virtual",
    "yield",
    "async",
    "await",
    "dyn",
    "as",
    "break",
    "const",
    "continue",
    "crate",
    "else",
    "enum",
    "extern",
    "false",
    "fn",
    "for",
    "if",
    "impl",
    "in",
    "let",
    "loop",
    "match",
    "mod",
    "move",
    "mut",
    "pub",
    "ref",
    "return",
    "self",
    "Self",
    "static",
    "struct",
    "super",
    "trait",
    "true",
    "type",
    "unsafe",
    "use",
    "where",
    "while",
]

escape : Str -> RustType
escape = \identifier ->
    if Set.contains reservedKeywords identifier then
        "r#$(identifier)"
    else
        identifier

rustTypeName : Types, TypeId -> RustType
rustTypeName = \types, type ->
    helper = \id -> rustTypeName types id

    when Types.shape types type is
        RocStr -> "roc_std::RocStr"
        Bool -> "bool"
        Num U8 -> "u8"
        Num I8 -> "i8"
        Num U16 -> "u16"
        Num I16 -> "i16"
        Num U32 -> "u32"
        Num I32 -> "i32"
        Num U64 -> "u64"
        Num I64 -> "i64"
        Num U128 -> "u128"
        Num I128 -> "i128"
        Num F32 -> "f32"
        Num F64 -> "f64"
        Num Dec -> "roc_std::RocDec"
        RocResult a b -> "roc_std::RocResult<$(helper a), $(helper b)>"
        RocList a -> "roc_std::RocList<$(helper a)>"
        RocBox a -> "roc_std::RocBox<$(helper a)>"
        TagUnion (Enumeration { name }) -> escape name
        TagUnion (NonRecursive { name }) -> escape name
        TagUnion (Recursive { name }) -> escape name
        TagUnion (NullableWrapped { name }) -> escape name
        TagUnion (NonNullableUnwrapped { name }) -> escape name
        TagUnion (SingleTagStruct { name }) -> escape name
        TagUnion (NullableUnwrapped { name }) -> escape name
        EmptyTagUnion -> crash "should never happen"
        Struct { name } -> escape name
        Function { functionName } -> escape functionName
        TagUnionPayload { name } -> escape name
        Unit -> "()"
        RecursivePointer _ | Unsized -> crash "what"
        RocDict _ _ | RocSet _ -> crash "todo"

# indents all lines except the first so multiline substitions play nice in string interpolation
# e.g:
# """
# fn do_stuff() {
#     $(stuff |> indentedBy 1)
# }
# """
indentedBy : Str, U64 -> Str
indentedBy = \code, amount ->
    indent = Str.repeat "\t" amount

    Str.replaceEach code "\n" "\n$(indent)"

derivesList : Set Trait -> Str
derivesList = \traits ->
    traits
    |> Set.toList
    |> List.map \trait ->
        when trait is
            Clone -> "Clone"
            Copy -> "Copy"
            Default -> "Default"
            PartialEq -> "PartialEq"
            Eq -> "Eq"
            PartialOrd -> "PartialOrd"
            Ord -> "Ord"
            Hash -> "Hash"
            Debug -> "Debug"
    |> Str.joinWith ", "

generateTld : Tld -> Str
generateTld = \tld ->
    when tld is
        EntryPoint { name, args, result } ->
            argList =
                args
                |> List.mapWithIndex \type, n -> "arg$(Num.toStr n): $(type)"
                |> Str.joinWith ", "

            callArgs =
                args
                |> List.mapWithIndex \_, n -> "arg$(Num.toStr n)"
                |> Str.joinWith ", "

            """
            pub fn $(name)($(argList)) -> $(result) {
                extern "C" {
                    fn roc__$(name)_1_exposed_generic(ret: *mut $(result), $(argList));
                }

                let mut ret = core::mem::MaybeUninit::uninit();

                unsafe {
                    roc__$(name)_1_exposed_generic(ret.as_mut_ptr(), $(callArgs));

                    ret.assume_init()
                }
            }
            """

        RecordStructDef { name, fields: fieldNames, derives } ->
            fields =
                fieldNames
                |> List.map \{ name: fieldName, type } -> "pub $(fieldName): $(type),"
                |> Str.joinWith "\n"

            """
            #[repr(C)]
            #[derive($(derivesList derives))]
            pub struct $(name) {
                $(fields |> indentedBy 1)
            }
            """

        RefcountImpl { name, kind: Noop } ->
            "roc_refcounted_noop_impl!($(name));"

        RefcountImpl { name, kind: Struct { fields } } ->
            incs =
                fields
                |> List.map \field -> "self.$(field).inc();"
                |> Str.joinWith "\n"

            decs =
                fields
                |> List.map \field -> "self.$(field).dec();"
                |> Str.joinWith "\n"

            """
            impl roc_std::RocRefcounted for $(name) {
                fn inc(&mut self) {
                    $(incs |> indentedBy 2)
                }

                fn dec(&mut self) {
                    $(decs |> indentedBy 2)
                }

                fn is_refcounted() -> bool { true }
            }
            """

        EnumerationEnumDef { name, tags: tagNames, repr, derives } ->
            tags =
                tagNames
                |> List.mapWithIndex \tag, i -> "$(tag) = $(Num.toStr i),"
                |> Str.joinWith "\n"

            """
            #[repr($(repr))]
            #[derive($(derivesList derives))]
            pub enum $(name) {
                $(tags |> indentedBy 1)
            }
            """

        EnumerationDebugImpl { name, tags } ->
            matchArms =
                tags
                |> List.map \tag ->
                    "Self::$(tag) => f.write_str(\"$(name)::$(tag)\"),"
                |> Str.joinWith "\n"

            """
            impl core::fmt::Debug for $(name) {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        $(matchArms |> indentedBy 3)
                    }
                }
            }
            """

        PayloadUnionDef { name, variants } ->
            variantDecls =
                variants
                |> List.map \{ tag, payload } -> "$(tag): $(payload),"
                |> Str.joinWith "\n"

            """
            #[repr(C)]
            pub union $(name) {
                $(variantDecls |> indentedBy 1)
            }
            """

        NonRecTagUnionDef { name, payload, discriminant, discriminantOffset, derives } ->
            """
            #[repr(C)]
            #[derive($(derivesList derives))]
            pub struct $(name) {
                payload: $(payload),
                discriminant: $(discriminant),
            }

            const DISCRIMINANT_OFFSET_CHECK: () = assert_eq!(core::mem::offset_of!($(name), discriminant), $(Inspect.toStr discriminantOffset));
            """

        RustNonRecTagUnionDef { name, variants, derives } ->
            variantDecls =
                variants
                |> List.map \{ tag, payload } -> "$(tag)($(payload))," # TODO: have these payloads be RustTypes (`()` in the event there's no payload)
                |> Str.joinWith "\n"

            """
            #[repr(C)]
            #[derive($(derivesList derives))]
            pub enum $(name) {
                $(variantDecls |> indentedBy 1)
            }
            """

        NonRecTagUnionConversionImpls { rocType, rustType, discriminant, union } ->
            """
            impl From<$(rocType)> for $(rustType) {
                fn from(item: $(rocType)) -> Self {
                    #[repr(C)]
                    struct Temp {
                        discriminant: $(discriminant),
                        payload: $(union),
                    }

                    let with_swapped_fields = Temp {
                        discriminant: item.discriminant,
                        payload: item.payload,
                    };

                    // SAFETY: Temp has the same layout as a #[repr(C)] enum, which is what $(rustType) is:
                    // https://doc.rust-lang.org/reference/type-layout.html#reprc-enums-with-fields
                    unsafe { core::mem::transmute::<Temp, $(rustType)>(with_swapped_fields) }
                }
            }

            impl From<$(rustType)> for $(rocType) {
                fn from(item: $(rustType)) -> Self {
                    #[repr(C)]
                    struct Temp {
                        discriminant: $(discriminant),
                        payload: $(union),
                    }

                    // SAFETY: Temp has the same layout as a #[repr(C)] enum, which is what $(rustType) is:
                    // https://doc.rust-lang.org/reference/type-layout.html#reprc-enums-with-fields
                    let decomposed = unsafe { core::mem::transmute::<$(rocType), Temp>(item) };

                    $(rocType) {
                        payload: decomposed.payload,
                        discriminant: decomposed.discriminant,
                    }
                }
            }
            """
        
        NonRecTagUnionDebugImpl { name, tags } ->
            
            matchArms =
                tags
                |> List.map \tag ->
                    if tag == "()"
                        """
                        $(tag) => {
                            "$(name)::$(tag)"
                        },
                        """
                    else
                        """
                        $(tag) => {
                            f.debug_tuple("$(name)::$(tag)").field(&self.payload.$(tag)).finish()
                        },
                        """
                |> List.joinWith "\n"

            """
            impl core::fmt::Debug for $(name) {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    use $(name)::*;

                    // SAFETY: discriminant is matched on before accessing union
                    unsafe {
                        match self.discriminant {
                            $(matchArms |> indentedBy 4)
                        }
                    }
                }
            }
            """
