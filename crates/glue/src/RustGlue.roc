app [makeGlue] { pf: platform "../platform/main.roc" }

import pf.Types exposing [Types]
import pf.File exposing [File]
import pf.TypeId exposing [TypeId]
import "../static/Cargo.toml" as rocAppCargoToml : Str
import "../../roc_std/Cargo.toml" as rocStdCargoToml : Str
import "../../roc_std/src/lib.rs" as rocStdLib : Str
import "../../roc_std/src/roc_box.rs" as rocStdBox : Str
import "../../roc_std/src/roc_list.rs" as rocStdList : Str
import "../../roc_std/src/roc_str.rs" as rocStdStr : Str
import "../../roc_std/src/storage.rs" as rocStdStorage : Str

makeGlue : List Types -> Result (List File) Str
makeGlue = \typesByArch ->
    archFiles = typesByArch |> List.map generateArchFile
    debugFile = { name: "debug.txt", content: Inspect.toStr typesByArch }
    modFile = { name: "roc_app/src/lib.rs", content: modFileContent typesByArch }

    archFiles
    |> List.append modFile
    |> List.append debugFile
    |> List.concat staticFiles
    |> Ok

modFileContent = \typesByArch ->
    List.walk typesByArch fileHeader \content, types ->
        archStr =
            types
            |> Types.target
            |> .architecture
            |> archName

        Str.concat
            content
            """
            #[cfg(target_arch = "$(archStr)")]
            mod $(archStr);
            #[cfg(target_arch = "$(archStr)")]
            pub use $(archStr)::*;


            """

fileHeader =
    """
    // ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

    // #![allow(unused_unsafe)]
    // #![allow(dead_code)]
    // #![allow(unused_mut)]
    #![allow(non_snake_case)]
    #![allow(non_camel_case_types)]
    #![allow(non_upper_case_globals)]
    // #![allow(clippy::undocumented_unsafe_blocks)]
    // #![allow(clippy::redundant_static_lifetimes)]
    #![allow(clippy::unused_unit)]
    // #![allow(clippy::let_and_return)]
    // #![allow(clippy::needless_borrow)]
    // #![allow(clippy::clone_on_copy)]
    // #![allow(clippy::non_canonical_partial_ord_impl)]

    #![allow(unused_imports)]
    #![allow(clippy::unit_cmp)]
    #![allow(clippy::unit_arg)]
    #![allow(clippy::unit_hash)]

    use roc_std::RocRefcounted;
    use roc_std::roc_refcounted_noop_impl;


    """

## These are always included, and don't depend on the specifics of the app.
staticFiles : List File
staticFiles = [
    { name: "roc_app/Cargo.toml", content: rocAppCargoToml },
    { name: "roc_std/Cargo.toml", content: rocStdCargoToml },
    { name: "roc_std/src/lib.rs", content: rocStdLib },
    { name: "roc_std/src/roc_box.rs", content: rocStdBox },
    { name: "roc_std/src/roc_list.rs", content: rocStdList },
    { name: "roc_std/src/roc_str.rs", content: rocStdStr },
    { name: "roc_std/src/storage.rs", content: rocStdStorage },
]

generateArchFile : Types -> File
generateArchFile = \types ->
    content =
        List.concat (typesToItemGroups types) (entrypoints types)
        |> List.map generateItemGroup
        |> Str.joinWith "\n\n"
        |> Str.withPrefix fileHeader

    archStr =
        types
        |> Types.target
        |> .architecture
        |> archName

    {
        name: "roc_app/src/$(archStr).rs",
        content,
    }

archName = \arch ->
    when arch is
        Aarch32 -> "arm"
        Aarch64 -> "aarch64"
        Wasm32 -> "wasm32"
        X86x32 -> "x86"
        X86x64 -> "x86_64"

supportedTraits : Types, TypeId -> Set Trait
supportedTraits = \types, type ->
    traitsHelper = \id -> supportedTraits types id

    fieldsHelper = \fields, allowed ->
        fields
        |> List.map \{ id } -> traitsHelper id
        |> List.walk allowed Set.intersection

    tagsHelper = \tags, allowed ->
        tags
        |> List.keepOks \{ payload } ->
            when payload is
                Some id -> Ok (traitsHelper id)
                None -> Err NoPayload
        |> List.walk allowed Set.intersection

    when Types.shape types type is
        Num F32 | Num F64 ->
            Set.fromList [Clone, Copy, Default, PartialEq, PartialOrd]

        Num _ | Bool | Unit ->
            Set.fromList [Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash]

        TagUnion (Enumeration _) ->
            Set.fromList [Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash]

        RocStr ->
            Set.fromList [Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash]

        RocList a ->
            Set.fromList [Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
            |> Set.intersection (traitsHelper a)
            |> Set.insert Default # Default returns `[]`, so `a` need not implement Default

        RocResult ok err ->
            Set.fromList [Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
            |> Set.intersection (traitsHelper ok)
            |> Set.intersection (traitsHelper err)

        RocBox a ->
            Set.fromList [PartialEq, Eq, PartialOrd, Ord, Hash]
            |> Set.intersection (traitsHelper a)
            |> Set.insert Clone # Clone clones the pointer, not the value
            |> Set.insert Hash # Hash hashes the pointer, not the value

        RocDict _ _ ->
            crash "Dict is not yet implemented in roc_std"

        RocSet _ ->
            crash "Set is not yet implemented in roc_std"

        Unsized ->
            # TODO: is this correct?
            # thusfar I've only seen `Unsized` be used as the type
            # referenced as the lambdaset in a `Function`
            # and the derivable traits of a `Function` don't depend on this
            # so this should be empty I think?
            Set.empty {}

        EmptyTagUnion ->
            crash "this should probably be made to never happen"

        Function _
        | Struct { fields: HasClosure _ }
        | TagUnionPayload { fields: HasClosure _ }
        | TagUnion (SingleTagStruct { payload: HasClosure _ }) ->
            # Set.single Debug
            Set.empty {}

        Struct { fields: HasNoClosure fields } ->
            allowed = Set.fromList [Clone, Copy, Default, PartialOrd, Ord, PartialEq, Eq, Hash]
            fieldsHelper fields allowed

        TagUnionPayload { fields: HasNoClosure fields } ->
            allowed = Set.fromList [Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash]
            fieldsHelper fields allowed

        TagUnion (SingleTagStruct { payload: HasNoClosure fields }) ->
            allowed = Set.fromList [Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash]
            fieldsHelper fields allowed

        TagUnion (NonRecursive { tags }) ->
            allowed = Set.fromList [Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash]
            tagsHelper tags allowed

        # the `{ tags: tags } situation is due to https://github.com/roc-lang/roc/issues/7167
        TagUnion (Recursive { tags: tags })
        | TagUnion (NullableWrapped { tags: tags }) ->
            allowed = Set.fromList [Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
            tagsHelper tags allowed

        TagUnion (NonNullableUnwrapped { payload })
        | TagUnion (NullableUnwrapped { nonNullPayload: payload }) ->
            Set.fromList [Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
            |> Set.intersection (traitsHelper payload)

        RecursivePointer _ ->
            # TODO: is this correct?
            # encountering a RecursivePointer means we should have already
            # encountered the thing it's pointing to
            # so it wouldn't disqualify it from anything a recursive tag union
            # isn't already disqualified from
            Set.fromList [Clone, PartialEq, Eq, PartialOrd, Ord, Hash]

RustSymbol : Str
RustType : Str

# `Debug` is not included here, as it is always implemented.
Trait : [
    Clone,
    Copy,
    Default,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
]

ItemGroup : [
    Entrypoint
        {
            name : RustSymbol,
            number : U64,
            args : List RustType,
            ret : RustType,
        },
    Record
        {
            name : RustSymbol,
            fields : List { name : RustSymbol, type : RustType },
            derives : Set Trait,
        },
    TagUnion
        [
            Enumeration
                {
                    name : RustSymbol,
                    repr : RustType,
                    tags : List RustSymbol,
                },
            NonRecursive
                {
                    name : RustSymbol,
                    rustEnumName : RustSymbol,
                    size : U32,
                    align : U32,
                    discriminant : {
                        name : RustSymbol,
                        size : U32,
                        offset : U32,
                    },
                    union : {
                        name : RustSymbol,
                        size : U32,
                        align : U32,
                    },
                    variants : List { name : RustSymbol, payload : RustType, isCopy : Bool },
                    traits : Set Trait,
                },
            SingleTagStruct
                {
                    name : RustSymbol,
                    tagName : RustSymbol,
                    fields : List RustType,
                    derives : Set Trait,
                },
            # Recursive,
        ],
]

entrypoints : Types -> List ItemGroup
entrypoints = \types ->
    types
    |> Types.entryPoints
    |> List.mapWithIndex \T name type, number ->
        (args, ret) =
            when Types.shape types type is
                Function func ->
                    nonUnitArgTypes = List.keepOks func.args \arg ->
                        when rustTypeName types arg is
                            "()" -> Err WasUnit
                            nonUnitType -> Ok nonUnitType

                    (
                        nonUnitArgTypes,
                        rustTypeName types func.ret,
                    )

                _ -> ([], rustTypeName types type)
        Entrypoint { name, number: number + 1, args, ret }

typesToItemGroups : Types -> List ItemGroup
typesToItemGroups = \types ->
    Types.walkShapes types [] \itemGroups, _, type ->
        List.appendIfOk itemGroups (typeToItemGroup types type)

typeToItemGroup : Types, TypeId -> Result ItemGroup [NoItemsNeeded]
typeToItemGroup = \types, type ->
    shape = Types.shape types type
    when shape is
        Struct { name: recordName, fields } ->
            getFields = \{ name, id } -> { name, type: rustTypeName types id }

            recordFields =
                when fields is
                    HasNoClosure list -> List.map list getFields
                    HasClosure list -> List.map list getFields

            Record {
                name: escape recordName,
                fields: recordFields,
                derives: supportedTraits types type,
            }
            |> Ok

        TagUnion (Enumeration { name, tags, size }) ->
            Ok (TagUnion (Enumeration { name: escape name, repr: discriminantRepr size, tags }))

        TagUnion (NonRecursive { name, tags, discriminantSize, discriminantOffset }) ->
            unionAlignment =
                List.walk tags 1 \acc, { payload } ->
                    when payload is
                        Some payloadId -> Num.max acc (Types.alignment types payloadId)
                        None -> acc

            unionSize =
                List.walk tags 1 \acc, { payload } ->
                    when payload is
                        Some payloadId -> Num.max acc (Types.size types payloadId)
                        None -> acc
                |> nextMultipleOf unionAlignment

            variants = List.map tags \tag ->
                when tag.payload is
                    None ->
                        {
                            name: tag.name,
                            payload: "()",
                            isCopy: Bool.true,
                        }

                    Some id ->
                        {
                            name: tag.name,
                            payload: rustTypeName types id,
                            isCopy: supportedTraits types id |> Set.contains Copy,
                        }

            {
                name: escape name,
                rustEnumName: "rusty_$(name)",
                size: Types.size types type,
                align: Types.alignment types type,
                discriminant: {
                    name: "discriminant_$(name)",
                    size: discriminantSize,
                    offset: discriminantOffset,
                },
                union: {
                    name: "union_$(name)",
                    size: unionSize,
                    align: unionAlignment,
                },
                variants,
                traits: supportedTraits types type,
            }
            |> NonRecursive
            |> TagUnion
            |> Ok

        TagUnion (SingleTagStruct { name, payload, tagName }) ->
            fields =
                rustFieldNames = \list -> List.map list \{ id } -> rustTypeName types id

                when payload is
                    HasNoClosure list -> rustFieldNames list
                    HasClosure list -> rustFieldNames list

            {
                name: escape name,
                tagName,
                fields,
                derives: supportedTraits types type,
            }
            |> SingleTagStruct
            |> TagUnion
            |> Ok

        # TagUnion (Recursive { name, tags, discriminantSize, discriminantOffset }) ->
        # crash "todo"
        Function { isToplevel } if isToplevel ->
            # taken care of by `entrypoints`
            Err NoItemsNeeded

        Unit
        | Unsized
        | EmptyTagUnion
        | Num _
        | Bool
        | RocResult _ _
        | RocStr
        | RocDict _ _
        | RocSet _
        | RocList _
        | RocBox _ ->
            # these are taken care of by the Roc std library
            # or represented as Rust builtins
            Err NoItemsNeeded

        RecursivePointer _ ->
            # doesn't require a tld
            Err NoItemsNeeded

        _ -> crash "todo: $(Inspect.toStr shape)"

discriminantRepr : U32 -> RustType
discriminantRepr = \bytes ->
    when bytes is
        0 -> crash "this is definitely a bug!"
        1 -> "u8"
        2 -> "u16"
        3 | 4 -> "u32"
        5 | 6 | 7 | 8 -> "u64"
        _ -> crash "this is probably a bug!"

nextMultipleOf = \lhs, rhs ->
    when lhs % rhs is
        0 -> lhs
        r -> lhs + (rhs - r)

reservedKeywords = Set.fromList [
    "try",
    "abstract",
    "become",
    "box",
    "do",
    "final",
    "macro",
    "override",
    "priv",
    "typeof",
    "unsized",
    "virtual",
    "yield",
    "async",
    "await",
    "dyn",
    "as",
    "break",
    "const",
    "continue",
    "crate",
    "else",
    "enum",
    "extern",
    "false",
    "fn",
    "for",
    "if",
    "impl",
    "in",
    "let",
    "loop",
    "match",
    "mod",
    "move",
    "mut",
    "pub",
    "ref",
    "return",
    "self",
    "Self",
    "static",
    "struct",
    "super",
    "trait",
    "true",
    "type",
    "unsafe",
    "use",
    "where",
    "while",
]

escape : Str -> RustType
escape = \identifier ->
    if Set.contains reservedKeywords identifier then
        # use a raw identifier for this, to prevent a syntax error due to using a reserved keyword.
        # https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html
        # another design would be to add an underscore after it; this is an experiment!
        "r#$(identifier)"
    else
        identifier

rustTypeName : Types, TypeId -> RustType
rustTypeName = \types, type ->
    helper = \id -> rustTypeName types id

    when Types.shape types type is
        RocStr -> "roc_std::RocStr"
        Bool -> "bool"
        Num U8 -> "u8"
        Num I8 -> "i8"
        Num U16 -> "u16"
        Num I16 -> "i16"
        Num U32 -> "u32"
        Num I32 -> "i32"
        Num U64 -> "u64"
        Num I64 -> "i64"
        Num U128 -> "u128"
        Num I128 -> "i128"
        Num F32 -> "f32"
        Num F64 -> "f64"
        Num Dec -> "roc_std::RocDec"
        RocResult a b -> "roc_std::RocResult<$(helper a), $(helper b)>"
        RocList a -> "roc_std::RocList<$(helper a)>"
        RocBox a -> "roc_std::RocBox<$(helper a)>"
        TagUnion (Enumeration { name }) -> escape name
        TagUnion (NonRecursive { name }) -> escape name
        TagUnion (Recursive { name }) -> escape name
        TagUnion (NullableWrapped { name }) -> escape name
        TagUnion (NonNullableUnwrapped { name }) -> escape name
        TagUnion (SingleTagStruct { name }) -> escape name
        TagUnion (NullableUnwrapped { name }) -> escape name
        EmptyTagUnion -> crash "should never happen"
        Struct { name } -> escape name
        Function { functionName } -> escape functionName
        TagUnionPayload { name } -> escape name
        Unit -> "()"
        RecursivePointer _ | Unsized -> crash "what"
        RocDict _ _ | RocSet _ -> crash "todo"

## indents all lines except the first so multiline substitions play nice in string interpolation
## e.g:
## """
## fn do_stuff() {
##     $(stuff |> indentedBy 1)
## }
## """
indentedBy : Str, U64 -> Str
indentedBy = \code, amount ->
    indent = Str.repeat "\t" amount

    Str.replaceEach code "\n" "\n$(indent)"

## appends code snippet to existing code if applicable
appendIfOk : Str, Result Str * -> Str
appendIfOk = \code, maybeSnippet ->
    when maybeSnippet is
        Ok snippet -> concatCode code snippet
        Err _ -> code

concatCode : Str, Str -> Str
concatCode = \snippetA, snippetB ->
    """
    $(snippetA)

    $(snippetB)
    """

derivesList : Set Trait -> Str
derivesList = \traits ->
    traits
    |> Set.toList
    |> List.map \trait ->
        when trait is
            Clone -> "Clone"
            Copy -> "Copy"
            Default -> "Default"
            PartialEq -> "PartialEq"
            Eq -> "Eq"
            PartialOrd -> "PartialOrd"
            Ord -> "Ord"
            Hash -> "Hash"
    |> Str.joinWith ", "

generateItemGroup : ItemGroup -> Str
generateItemGroup = \itemGroup ->
    when itemGroup is
        Entrypoint { name, number, args, ret } ->
            defArgs =
                args
                |> List.mapWithIndex \type, n -> "arg$(Num.toStr n): $(type)"
                |> Str.joinWith ", "

            callArgs =
                args
                |> List.mapWithIndex \_, n -> "arg$(Num.toStr n)"
                |> Str.joinWith ", "

            """
            pub fn $(name)($(defArgs)) -> $(ret) {
                extern "C" {
                    fn roc__$(name)_$(Num.toStr number)_exposed_generic(ret: *mut $(ret), $(defArgs));
                }

                let mut ret = core::mem::MaybeUninit::uninit();

                unsafe {
                    roc__$(name)_1_exposed_generic(ret.as_mut_ptr(), $(callArgs));

                    ret.assume_init()
                }
            }
            """

        Record { name, fields, derives } ->
            incs =
                fields
                |> List.map \field -> "self.$(field.name).inc();"
                |> Str.joinWith "\n"

            decs =
                fields
                |> List.map \field -> "self.$(field.name).dec();"
                |> Str.joinWith "\n"

            fieldList =
                fields
                |> List.map \field -> "pub $(field.name): $(field.type),"
                |> Str.joinWith "\n"

            refcounted =
                if Set.contains derives Copy then
                    "false"
                else
                    "true"

            """
            #[repr(C)]
            #[derive(Debug)]
            #[derive($(derivesList derives))]
            pub struct $(name) {
                $(fieldList |> indentedBy 1)
            }

            impl roc_std::RocRefcounted for $(name) {
                fn inc(&mut self) {
                    $(incs |> indentedBy 2)
                }

                fn dec(&mut self) {
                    $(decs |> indentedBy 2)
                }

                fn is_refcounted() -> bool { $(refcounted) }
            }
            """

        TagUnion (Enumeration { name, repr, tags }) ->
            tagList =
                tags
                |> List.map \tag -> "$(tag),"
                |> Str.joinWith "\n"

            matchArms =
                tags
                |> List.map \tag ->
                    """
                    $(name)::$(tag) => f.write_str("$(name)::$(tag)"),
                    """
                |> Str.joinWith "\n"

            """
            #[repr($(repr))]
            #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
            pub enum $(name) {
                $(tagList |> indentedBy 1)
            }

            impl core::fmt::Debug for $(name) {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        $(matchArms |> indentedBy 3)
                    }
                }
            }

            roc_refcounted_noop_impl!($(name));
            """

        TagUnion (NonRecursive { name, rustEnumName, size, align, discriminant, union, variants, traits }) ->
            commonSnippet =
                tagList =
                    variants
                    |> List.map .name
                    |> Str.joinWith ",\n"

                unionVariantList =
                    variants
                    |> List.map \variant ->
                        if variant.isCopy then
                            "$(variant.name): $(variant.payload),"
                        else
                            "$(variant.name): core::mem::ManuallyDrop<$(variant.payload)>,"
                    |> Str.joinWith "\n"

                rustEnumList =
                    variants
                    |> List.map \variant ->
                        if variant.payload == "()" then
                            "$(variant.name),"
                        else
                            "$(variant.name)($(variant.payload)),"
                    |> Str.joinWith "\n"

                debugMatchArms =
                    variants
                    |> List.map \variant ->
                        # # TODO: maybe change the tests to allow this cause it looks better
                        # if variant.payload == "()" then
                        #     """
                        #     $(discriminant.name)::$(variant.name) => f.write_str("$(name)::$(variant.name)"),
                        #     """
                        # else
                        #     """
                        #     $(discriminant.name)::$(variant.name) => {
                        #         let payload: &$(variant.payload) = &self.payload.$(variant.name);
                        #         f.debug_tuple("$(name)::$(variant.name)").field(payload).finish()
                        #     }
                        #     """
                        """
                        $(discriminant.name)::$(variant.name) => {
                            let payload: &$(variant.payload) = &self.payload.$(variant.name);
                            f.debug_tuple("$(name)::$(variant.name)").field(payload).finish()
                        }
                        """
                    |> Str.joinWith "\n\n"

                discriminantDebugMatchArms =
                    variants
                    |> List.map \variant ->
                        """
                        $(discriminant.name)::$(variant.name) => f.write_str("$(discriminant.name)::$(variant.name)"),
                        """
                    |> Str.joinWith "\n"

                constructors =
                    variants
                    |> List.map \variant ->
                        constructor =
                            # TODO: split these into appropriate unsafe "_unchecked" methods and checked and panic-y versions
                            if variant.payload == "()" then
                                """
                                pub fn $(variant.name)() -> Self {
                                    Self {
                                        discriminant: $(discriminant.name)::$(variant.name),
                                        payload: $(union.name) {
                                            $(variant.name): (),
                                        }
                                    }
                                }
                                """
                            else if variant.isCopy then
                                # TODO: maybe rename the "borrow" methods to "copy_payload" or something more appropriate?
                                """
                                pub fn $(variant.name)(payload: $(variant.payload)) -> Self {
                                    Self {
                                        discriminant: $(discriminant.name)::$(variant.name),
                                        payload: $(union.name) {
                                            $(variant.name): payload,
                                        }
                                    }
                                }

                                pub fn unwrap_$(variant.name)(self) -> $(variant.payload) {
                                    debug_assert_eq!(self.discriminant, $(discriminant.name)::$(variant.name));
                                    unsafe { self.payload.$(variant.name) }
                                }

                                pub fn borrow_$(variant.name)(&mut self) -> $(variant.payload) {
                                    debug_assert_eq!(self.discriminant, $(discriminant.name)::$(variant.name));
                                    unsafe { self.payload.$(variant.name) }
                                }
                                """
                            else
                                """
                                pub fn $(variant.name)(payload: $(variant.payload)) -> Self {
                                    Self {
                                        discriminant: $(discriminant.name)::$(variant.name),
                                        payload: $(union.name) {
                                            $(variant.name): core::mem::ManuallyDrop::new(payload),
                                        }
                                    }
                                }

                                pub fn unwrap_$(variant.name)(mut self) -> $(variant.payload) {
                                    debug_assert_eq!(self.discriminant, $(discriminant.name)::$(variant.name));
                                    unsafe { core::mem::ManuallyDrop::take(&mut self.payload.$(variant.name)) }
                                }

                                pub fn borrow_$(variant.name)(&mut self) -> &$(variant.payload) {
                                    debug_assert_eq!(self.discriminant, $(discriminant.name)::$(variant.name));
                                    unsafe { &self.payload.$(variant.name) }
                                }
                                """

                        variantCheck =
                            """
                            pub fn is_$(variant.name)(&self) -> bool {
                                matches!(self.discriminant, $(discriminant.name)::$(variant.name))
                            }
                            """

                        borrowMut =
                            """
                            pub fn borrow_mut_$(variant.name)(&mut self) -> &mut $(variant.payload) {
                                debug_assert_eq!(self.discriminant, $(discriminant.name)::$(variant.name));
                                unsafe { &mut self.payload.$(variant.name) }
                            }
                            """

                        constructor
                        |> concatCode borrowMut
                        |> concatCode variantCheck
                    |> Str.joinWith "\n\n"

                (incMatchArms, decMatchArms) =
                    refcountMatchArms = \methodName ->
                        variants
                        |> List.map \variant ->
                            if variant.isCopy then
                                "$(discriminant.name)::$(variant.name) => self.payload.$(variant.name).$(methodName)(),"
                            else
                                # this has to be explicitly dereferenced, because the compiler is scared that an implicit
                                # DerefMut will cause us to accidentally call Drop when we didn't intend to. Decrementing the
                                # refcount may technically cause the underlying data to be dropped, but at that point the union
                                # needs not be valid anymore anyway, as it means we're no longer using it.
                                "$(discriminant.name)::$(variant.name) => (*self.payload.$(variant.name)).$(methodName)(),"
                        |> Str.joinWith "\n"

                    (refcountMatchArms "inc", refcountMatchArms "dec")

                """
                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
                #[repr($(discriminant.size |> discriminantRepr))]
                pub enum $(discriminant.name) {
                    $(tagList |> indentedBy 1)
                }

                #[repr(C, align($(union.align |> Num.toStr)))]
                pub union $(union.name) {
                    $(unionVariantList |> indentedBy 1)
                }

                // This will break when #7171 is fixed:
                // https://github.com/roc-lang/roc/issues/7171
                #[repr(C)]
                pub struct $(name) {
                    payload: $(union.name),
                    discriminant: $(discriminant.name),
                }

                /// a rust enum equivalent of $(name).
                /// safer/more convenient to work with, but does require rearranging some memory to get.
                #[repr(C)]
                #[derive($(derivesList traits))]
                pub enum $(rustEnumName) {
                    $(rustEnumList |> indentedBy 1)
                }

                const _SIZE_CHECK_$(union.name): () =
                    assert!(core::mem::size_of::<$(union.name)>() == $(union.size |> Num.toStr));

                const _ALIGN_CHECK_$(union.name): () =
                    assert!(core::mem::align_of::<$(union.name)>() == $(union.align |> Num.toStr));

                const _SIZE_CHECK_$(name): () =
                    assert!(core::mem::size_of::<$(name)>() == $(size |> Num.toStr));

                const _ALIGN_CHECK_$(name): () =
                    assert!(core::mem::align_of::<$(name)>() == $(align |> Num.toStr));

                // tag constructors, variant check methods, and payload borrow/unwrap methods
                impl $(name) {
                    /// Returns which variant this tag union holds. Note that this never includes a payload!
                    pub fn discriminant(&self) -> $(discriminant.name) {
                        self.discriminant
                    }

                    $(constructors |> indentedBy 1)
                }

                impl From<$(name)> for $(rustEnumName) {
                    fn from(item: $(name)) -> Self {
                        #[repr(C)]
                        struct Temp {
                            discriminant: $(discriminant.name),
                            payload: $(union.name),
                        }

                        // SAFETY: moving non-copy fields out of `item` is normally disallowed,
                        // since we'd be circumventing the destructor. Since we mem::forget `item` after this,
                        // and the newly created $(rustEnumName) is put in charge of running the destructors afterwards, this is safe.
                        let with_swapped_fields = unsafe {
                            Temp {
                                discriminant: core::ptr::read(&item.discriminant),
                                payload: core::ptr::read(&item.payload),
                            }
                        };

                        core::mem::forget(item);

                        // SAFETY: Temp has the same layout as a #[repr(C)] enum, which is what $(rustEnumName) is:
                        // https://doc.rust-lang.org/reference/type-layout.html#reprc-enums-with-fields
                        unsafe { core::mem::transmute::<Temp, $(rustEnumName)>(with_swapped_fields) }
                    }
                }

                impl From<$(rustEnumName)> for $(name) {
                    fn from(item: $(rustEnumName)) -> Self {
                        #[repr(C)]
                        struct Temp {
                            discriminant: $(discriminant.name),
                            payload: $(union.name),
                        }

                        // SAFETY: Temp has the same layout as a #[repr(C)] enum, which is what $(rustEnumName) is:
                        // https://doc.rust-lang.org/reference/type-layout.html#reprc-enums-with-fields
                        let decomposed = unsafe { core::mem::transmute::<$(rustEnumName), Temp>(item) };

                        $(name) {
                            payload: decomposed.payload,
                            discriminant: decomposed.discriminant,
                        }
                    }
                }

                impl roc_std::RocRefcounted for $(name) {
                    fn inc(&mut self) {
                        unsafe {
                            match self.discriminant {
                                $(incMatchArms |> indentedBy 4)
                            }
                        }
                    }
                    fn dec(&mut self) {
                        unsafe {
                            match self.discriminant {
                                $(decMatchArms |> indentedBy 4)
                            }
                        }
                    }
                    fn is_refcounted() -> bool { $(if Set.contains traits Copy then "false" else "true") }
                }

                impl core::fmt::Debug for $(name) {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        unsafe {
                            match self.discriminant {
                                $(debugMatchArms |> indentedBy 4)
                            }
                        }
                    }
                }

                impl core::fmt::Debug for $(discriminant.name) {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        match self {
                            $(discriminantDebugMatchArms |> indentedBy 4)
                        }
                    }
                }
                """

            copySnippet =
                if Set.contains traits Copy then
                    Ok "impl Copy for $(name) {}"
                else
                    Err NoCopy

            dropSnippet =
                if Set.contains traits Copy then
                    Err NothingToDrop
                else
                    matchArms =
                        variants
                        |> List.map \variant ->
                            if variant.isCopy then
                                "$(discriminant.name)::$(variant.name) => {},"
                            else
                                "$(discriminant.name)::$(variant.name) => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.$(variant.name)); },"
                        |> Str.joinWith "\n"

                    """
                    impl Drop for $(name) {
                        fn drop(&mut self) {
                            // manually drop the payloads if applicable
                            match self.discriminant() {
                                $(matchArms |> indentedBy 3)
                            }
                        }
                    }
                    """
                    |> Ok

            partialEqSnippet =
                if Set.contains traits PartialEq then
                    matchArms =
                        variants
                        |> List.map \variant ->
                            "$(discriminant.name)::$(variant.name) => self.payload.$(variant.name) == other.payload.$(variant.name),"
                        |> Str.joinWith "\n"

                    """
                    impl PartialEq for $(name) {
                        fn eq(&self, other: &Self) -> bool {
                            if self.discriminant != other.discriminant {
                                return false;
                            }

                            // SAFETY: `self.discriminant` is matched upon, `other.discriminant` was checked above
                            unsafe {
                                match self.discriminant {
                                    $(matchArms |> indentedBy 4)
                                }
                            }
                        }
                    }
                    """
                    |> Ok
                else
                    Err NoPartialEq

            eqSnippet =
                if Set.contains traits Eq then
                    Ok "impl Eq for $(name) {}"
                else
                    Err NoTotalEq

            cloneSnippet =
                if Set.contains traits Clone then
                    matchArms =
                        variants
                        |> List.map \variant ->
                            if variant.isCopy then
                                """
                                $(discriminant.name)::$(variant.name) => $(union.name) {
                                    $(variant.name): self.payload.$(variant.name),
                                },
                                """
                            else
                                """
                                $(discriminant.name)::$(variant.name) => $(union.name) {
                                    $(variant.name): self.payload.$(variant.name).clone(),
                                },
                                """
                        |> Str.joinWith "\n\n"

                    """
                    impl core::clone::Clone for $(name) {
                        fn clone(&self) -> Self {
                            use $(discriminant.name)::*;

                            let payload = unsafe {
                                match self.discriminant {
                                    $(matchArms |> indentedBy 4)
                                }
                            };

                            Self {
                                discriminant: self.discriminant,
                                payload,
                            }
                        }
                    }
                    """
                    |> Ok
                else
                    Err NotCloneable

            cmpSnippet =
                if Set.contains traits Ord then
                    matchArms =
                        variants
                        |> List.map \variant ->
                            "$(discriminant.name)::$(variant.name) => self.payload.$(variant.name).cmp(&other.payload.$(variant.name)),"
                        |> Str.joinWith "\n"

                    """
                    impl core::cmp::Ord for $(name) {
                        fn cmp(&self, other: &Self) -> core::cmp::Ordering {
                            match self.discriminant.cmp(&other.discriminant) {
                                core::cmp::Ordering::Less => core::cmp::Ordering::Less,
                                core::cmp::Ordering::Greater => core::cmp::Ordering::Greater,
                                core::cmp::Ordering::Equal =>
                                    // SAFETY: self.discriminant checked below, other.discriminant checked by virtue of them being checked to be equal above
                                    unsafe {
                                        match self.discriminant {
                                            $(matchArms |> indentedBy 6)
                                        }
                                    },
                            }
                        }
                    }

                    impl core::cmp::PartialOrd for $(name) {
                        fn partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering> {
                            core::option::Option::Some(self.cmp(other))
                        }
                    }
                    """
                    |> Ok
                else if Set.contains traits PartialOrd then
                    matchArms =
                        variants
                        |> List.map \variant ->
                            "$(discriminant.name)::$(variant.name) => self.payload.$(variant.name).partial_cmp(&other.payload.$(variant.name)),"
                        |> Str.joinWith "\n"

                    """
                    impl core::cmp::PartialOrd for $(name) {
                        fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
                            match self.discriminant.cmp(&other.discriminant) {
                                core::cmp::Ordering::Less => Option::Some(core::cmp::Ordering::Less),
                                core::cmp::Ordering::Greater => Option::Some(core::cmp::Ordering::Greater),
                                core::cmp::Ordering::Equal =>
                                    // SAFETY: self.discriminant checked below, other.discriminant checked in virtue of them being checked to be equal above
                                    unsafe {
                                        match self.discriminant {
                                            $(matchArms |> indentedBy 6)
                                        }
                                    },
                            }
                        }
                    }
                    """
                    |> Ok
                else
                    Err NotOrderable

            hashSnippet =
                if Set.contains traits Hash then
                    matchArms =
                        variants
                        |> List.map \variant ->
                            "$(discriminant.name)::$(variant.name) => self.payload.$(variant.name).hash(state),"
                        |> Str.joinWith "\n"

                    """
                    impl core::hash::Hash for $(name) {
                        fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
                            unsafe {
                                match self.discriminant {
                                    $(matchArms |> indentedBy 4)
                                }
                            }
                        }
                    }
                    """
                    |> Ok
                else
                    Err NoHash

            commonSnippet
            |> appendIfOk cloneSnippet
            |> appendIfOk copySnippet
            |> appendIfOk dropSnippet
            |> appendIfOk partialEqSnippet
            |> appendIfOk eqSnippet
            |> appendIfOk cmpSnippet
            |> appendIfOk hashSnippet

        TagUnion (SingleTagStruct { name, tagName, fields, derives }) ->
            def =
                when fields is
                    [] ->
                        """
                        #[repr(transparent)]
                        #[derive($(derivesList derives))]
                        pub struct $(name);

                        impl $(name) {
                            pub const $(tagName): Self = Self;
                        }
                        """

                    [payload] ->
                        """
                        #[repr(transparent)]
                        #[derive($(derivesList derives))]
                        pub struct $(name)(pub $(payload));

                        impl $(name) {
                            pub fn $(tagName)(payload: $(payload)) -> Self {
                                Self(payload)
                            }
                        }
                        """

                    payloads ->
                        payloadList =
                            payloads
                            |> List.map \payload -> "pub $(payload)"
                            |> Str.joinWith ", "

                        init =
                            fields
                            |> List.mapWithIndex \_, i -> "payload.$(Num.toStr i)"
                            |> Str.joinWith ", "

                        """
                        #[repr(transparent)]
                        #[derive($(derivesList derives))]
                        /// warning: $(tagName)'s fields have been sorted by alignment;
                        /// they may not be in the same order they are in Roc.
                        /// if this is undesireable, consider using a record instead.
                        pub struct $(name)($(payloadList));

                        impl $(name) {
                            pub fn $(tagName)(payload: ($(Str.joinWith fields ", "))) -> Self {
                                    Self($(init))
                                }
                            }
                        }
                        """

            debugSnippet =
                if List.isEmpty fields then
                    """
                    impl core::fmt::Debug for $(name) {
                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                            f.write_str("$(name)::$(tagName)")
                        }
                    }
                    """
                else
                    fieldBuilders =
                        fields
                        |> List.mapWithIndex \_, i -> ".field(&self.$(Num.toStr i))"
                        |> Str.joinWith "\n"

                    """
                    impl core::fmt::Debug for $(name) {
                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                            f.debug_tuple("$(name)::$(tagName)")
                                $(fieldBuilders |> indentedBy 3)
                                .finish()
                        }
                    }
                    """

            refcountSnippet =
                if Set.contains derives Copy then
                    """
                    roc_refcounted_noop_impl!($(name));
                    """
                else
                    incs =
                        fields
                        |> List.mapWithIndex \_, i -> "self.$(Num.toStr i).inc();"
                        |> Str.joinWith "\n"

                    decs =
                        fields
                        |> List.mapWithIndex \_, i -> "self.$(Num.toStr i).dec();"
                        |> Str.joinWith "\n"

                    """
                    impl roc_std::RocRefcounted for $(name) {
                        fn inc(&mut self) {
                            $(incs |> indentedBy 2)
                        }

                        fn dec(&mut self) {
                            $(decs |> indentedBy 2)
                        }

                        fn is_refcounted() -> bool { true }
                    }
                    """

            def
            |> concatCode debugSnippet
            |> concatCode refcountSnippet
