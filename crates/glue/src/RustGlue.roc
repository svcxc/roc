app [makeGlue] { pf: platform "../platform/main.roc" }

import pf.Types exposing [Types]
import pf.Shape exposing [Shape, RocFn]
import pf.File exposing [File]
import pf.TypeId exposing [TypeId]
import "../static/Cargo.toml" as rocAppCargoToml : Str
import "../../roc_std/Cargo.toml" as rocStdCargoToml : Str
import "../../roc_std/src/lib.rs" as rocStdLib : Str
import "../../roc_std/src/roc_box.rs" as rocStdBox : Str
import "../../roc_std/src/roc_list.rs" as rocStdList : Str
import "../../roc_std/src/roc_str.rs" as rocStdStr : Str
import "../../roc_std/src/storage.rs" as rocStdStorage : Str

makeGlue : List Types -> Result (List File) Str
makeGlue = \typesByArch ->
    archFiles = typesByArch |> List.map generateArchFile
    debugFile = { name: "debug.txt", content: Inspect.toStr typesByArch }
    modFile = { name: "roc_app/src/lib.rs", content: modFileContent typesByArch }

    archFiles
    |> List.append modFile
    |> List.append debugFile
    |> List.concat staticFiles
    |> Ok

modFileContent = \typesByArch ->
    List.walk typesByArch fileHeader \content, types ->
        archStr =
            types
            |> Types.target
            |> .architecture
            |> archName

        Str.concat
            content
            """
            #[cfg(target_arch = "$(archStr)")]
            mod $(archStr);
            #[cfg(target_arch = "$(archStr)")]
            pub use $(archStr)::*;

            """

fileHeader =
    """
    // ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

    #![allow(unused_unsafe)]
    #![allow(dead_code)]
    #![allow(unused_mut)]
    #![allow(non_snake_case)]
    #![allow(non_camel_case_types)]
    #![allow(non_upper_case_globals)]
    #![allow(clippy::undocumented_unsafe_blocks)]
    #![allow(clippy::redundant_static_lifetimes)]
    #![allow(clippy::unused_unit)]
    #![allow(clippy::missing_safety_doc)]
    #![allow(clippy::let_and_return)]
    #![allow(clippy::missing_safety_doc)]
    #![allow(clippy::needless_borrow)]
    #![allow(clippy::clone_on_copy)]
    #![allow(clippy::non_canonical_partial_ord_impl)]


    use roc_std::RocRefcounted;
    use roc_std::roc_refcounted_noop_impl;


    """

## These are always included, and don't depend on the specifics of the app.
staticFiles : List File
staticFiles = [
    { name: "roc_app/Cargo.toml", content: rocAppCargoToml },
    { name: "roc_std/Cargo.toml", content: rocStdCargoToml },
    { name: "roc_std/src/lib.rs", content: rocStdLib },
    { name: "roc_std/src/roc_box.rs", content: rocStdBox },
    { name: "roc_std/src/roc_list.rs", content: rocStdList },
    { name: "roc_std/src/roc_str.rs", content: rocStdStr },
    { name: "roc_std/src/storage.rs", content: rocStdStorage },
]

generateArchFile : Types -> File
generateArchFile = \types ->
    content =
        types
        |> typesToTlds
        |> Set.map generateTld
        |> Set.toList
        |> Str.joinWith "\n\n"

    archStr =
        types
        |> Types.target
        |> .architecture
        |> archName

    {
        name: "roc_app/src/$(archStr).rs",
        content,
    }

archName = \arch ->
    when arch is
        Aarch32 -> "arm"
        Aarch64 -> "aarch64"
        Wasm32 -> "wasm32"
        X86x32 -> "x86"
        X86x64 -> "x86_64"

Symbol : Str
RustType : Str

StructFields : List { name : Symbol, type : RustType }

Tld : [
    EntryPoint
        {
            name : Symbol,
            args : List RustType,
            result : RustType,
        },
    RecordStructDef
        {
            name : Symbol,
            fields : StructFields,
        },
    RefcountImpl
        {
            name : Symbol,
            kind : [
                Struct
                    {
                        fields : List Symbol,
                    },
            ],
        },
]

typesToTlds : Types -> Set Tld
typesToTlds = \types ->
    Types.walkShapes types (Set.empty {}) \tlds, shape, _typeId ->
        Set.union tlds (shapeToTlds types shape)

shapeToTlds : Types, Shape -> Set Tld
shapeToTlds = \types, shape ->
    when shape is
        Struct { name, fields } -> structTlds types name fields
        Unit
        | Unsized
        | EmptyTagUnion
        | Num _
        | Bool
        | RocResult _ _
        | RocStr
        | RocDict _ _
        | RocSet _
        | RocList _
        | RocBox _ ->
            # these are taken care of by the Roc std library
            # or represented as Rust builtins
            Set.empty {}

        _ -> crash "todo"

structTlds : Types, Str, Shape.RocStructFields -> Set Tld
structTlds = \types, recordName, fields ->
    getFields = \list -> List.map list \{ name, id } -> { name, type: id }

    # this might be a problem, but the previous RustGlue doesn't do anything with this either
    justFields =
        when fields is
            HasNoClosure list -> getFields list
            HasClosure list -> getFields list

    rustRecordFields =
        justFields
        |> List.map \{ name, type } -> { name, type: rustTypeName types type }

    structDef =
        RecordStructDef {
            name: recordName,
            fields: rustRecordFields,
        }

    refcountImpl = RefcountImpl {
        name: recordName,
        # kind: Struct { fields },
        kind: Struct { fields: [] },
    }

    Set.fromList [structDef, refcountImpl]

rustTypeName : Types, TypeId -> RustType

# indents all lines except the first so multiline substitions play nice in string interpolation
# e.g:
# """
# fn do_stuff() {
#     $(stuff |> indentedBy 1)
# }
# """
indentedBy : Str, U64 -> Str
indentedBy = \code, amount ->
    indent = Str.repeat "\t" amount

    Str.replaceEach code "\n" "\n$(indent)"

generateTld : Tld -> Str
generateTld = \tld ->
    when tld is
        EntryPoint { name, args, result } ->
            argList =
                args
                |> List.mapWithIndex \type, n -> "arg$(Num.toStr n): $(type)"
                |> Str.joinWith ", "

            callArgs = Str.joinWith args ", "

            """
            pub fn $(name)($(argList)) -> $(result) {
                extern "C" {
                    fn roc__forHost_1_exposed_generic(ret: *mut $(result), $(argList));
                }

                let mut ret = core::mem::MaybeUninit::uninit();

                unsafe {
                    roc__$(name)_1_exposed_generic(ret.as_mut_ptr(), $(callArgs));

                    ret.assume_init()
                }
            }
            """

        RecordStructDef { name, fields: fieldNames } ->
            fields =
                fieldNames
                |> List.map \{ name: fieldName, type } -> "$(fieldName): $(type)"
                |> Str.joinWith "\n"

            # TODO
            derives = "#[derive()]"

            """
            #[repr(C)]
            $(derives)
            pub struct $(name) {
                $(fields |> indentedBy 1)
            }
            """

        RefcountImpl { name, kind: Struct { fields } } ->
            incs =
                fields
                |> List.map \field -> "$(field).inc();"
                |> Str.joinWith "\n"

            decs =
                fields
                |> List.map \field -> "$(field).dec();"
                |> Str.joinWith "\n"

            """
            impl roc_std::RocRefcounted for $(name) {
                fn inc() {
                    $(incs |> indentedBy 2)
                }

                fn dec() {
                    $(decs |> indentedBy 2)
                }

                fn is_refcounted() -> bool { true }
            }
            """
