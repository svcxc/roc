app [makeGlue] { pf: platform "../platform/main.roc" }

import pf.Types exposing [Types]
import pf.File exposing [File]
import pf.TypeId exposing [TypeId]
import pf.Target exposing [Architecture]
import "../static/Cargo.toml" as rocAppCargoToml : Str
import "../../roc_std/Cargo.toml" as rocStdCargoToml : Str
import "../../roc_std/src/lib.rs" as rocStdLib : Str
import "../../roc_std/src/roc_box.rs" as rocStdBox : Str
import "../../roc_std/src/roc_list.rs" as rocStdList : Str
import "../../roc_std/src/roc_str.rs" as rocStdStr : Str
import "../../roc_std/src/storage.rs" as rocStdStorage : Str

makeGlue : List Types -> Result (List File) Str
makeGlue = \typesByArch ->
    archFiles = typesByArch |> List.map generateArchFile
    debugFile = { name: "debug.txt", content: Inspect.toStr typesByArch }
    modFile = { name: "roc_app/src/lib.rs", content: modFileContent typesByArch }

    archFiles
    |> List.append modFile
    |> List.append debugFile
    |> List.concat staticFiles
    |> Ok

modFileContent = \typesByArch ->
    List.walk typesByArch fileHeader \content, types ->
        archStr =
            types
            |> Types.target
            |> .architecture
            |> archName

        Str.concat
            content
            """
            #[cfg(target_arch = "$(archStr)")]
            mod $(archStr);
            #[cfg(target_arch = "$(archStr)")]
            pub use $(archStr)::*;


            """

fileHeader =
    """
    // ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

    // #![allow(unused_unsafe)]
    // #![allow(dead_code)]
    // #![allow(unused_mut)]
    #![allow(non_snake_case)]
    #![allow(non_camel_case_types)]
    #![allow(non_upper_case_globals)]
    // #![allow(clippy::undocumented_unsafe_blocks)]
    // #![allow(clippy::redundant_static_lifetimes)]
    #![allow(clippy::unused_unit)]
    // #![allow(clippy::let_and_return)]
    // #![allow(clippy::needless_borrow)]
    // #![allow(clippy::clone_on_copy)]
    // #![allow(clippy::non_canonical_partial_ord_impl)]

    #![allow(unused_imports)]
    #![allow(clippy::unit_cmp)]
    #![allow(clippy::unit_arg)]
    #![allow(clippy::unit_hash)]

    use roc_std::RocRefcounted;
    use roc_std::roc_refcounted_noop_impl;


    """

## These are always included, and don't depend on the specifics of the app.
staticFiles : List File
staticFiles = [
    { name: "roc_app/Cargo.toml", content: rocAppCargoToml },
    { name: "roc_std/Cargo.toml", content: rocStdCargoToml },
    { name: "roc_std/src/lib.rs", content: rocStdLib },
    { name: "roc_std/src/roc_box.rs", content: rocStdBox },
    { name: "roc_std/src/roc_list.rs", content: rocStdList },
    { name: "roc_std/src/roc_str.rs", content: rocStdStr },
    { name: "roc_std/src/storage.rs", content: rocStdStorage },
]

generateArchFile : Types -> File
generateArchFile = \types ->
    content =
        List.concat (typesToItemGroups types) (entrypoints types)
        |> List.map generateItemGroup
        |> Str.joinWith "\n\n"
        |> Str.withPrefix fileHeader

    archStr =
        types
        |> Types.target
        |> .architecture
        |> archName

    {
        name: "roc_app/src/$(archStr).rs",
        content,
    }

archName = \arch ->
    when arch is
        Aarch32 -> "arm"
        Aarch64 -> "aarch64"
        Wasm32 -> "wasm32"
        X86x32 -> "x86"
        X86x64 -> "x86_64"

supportedTraits : Types, TypeId -> Set Trait
supportedTraits = \types, type ->
    traitsHelper = \id -> supportedTraits types id

    fieldsHelper = \fields, allowed ->
        fields
        |> List.map \{ id } -> traitsHelper id
        |> List.walk allowed Set.intersection

    tagsHelper = \tags, allowed ->
        tags
        |> List.keepOks \{ payload } ->
            when payload is
                Some id -> Ok (traitsHelper id)
                None -> Err NoPayload
        |> List.walk allowed Set.intersection

    when Types.shape types type is
        Num F32 | Num F64 ->
            Set.fromList [Clone, Copy, Default, PartialEq, PartialOrd]

        Num _ | Bool | Unit ->
            Set.fromList [Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash]

        TagUnion (Enumeration _) ->
            Set.fromList [Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash]

        RocStr ->
            Set.fromList [Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash]

        RocList a ->
            Set.fromList [Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
            |> Set.intersection (traitsHelper a)
            |> Set.insert Default # Default returns `[]`, so `a` need not implement Default

        RocResult ok err ->
            Set.fromList [Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
            |> Set.intersection (traitsHelper ok)
            |> Set.intersection (traitsHelper err)

        RocBox a ->
            Set.fromList [PartialEq, Eq, PartialOrd, Ord, Hash]
            |> Set.intersection (traitsHelper a)
            |> Set.insert Clone # Clone clones the pointer, not the value
            |> Set.insert Hash # Hash hashes the pointer, not the value

        RocDict _ _ ->
            crash "Dict is not yet implemented in roc_std"

        RocSet _ ->
            crash "Set is not yet implemented in roc_std"

        Unsized ->
            # TODO: is this correct?
            # thusfar I've only seen `Unsized` be used as the type
            # referenced as the lambdaset in a `Function`
            # and the derivable traits of a `Function` don't depend on this
            # so this should be empty I think?
            Set.empty {}

        EmptyTagUnion ->
            crash "this should probably be made to never happen"

        Function _
        | Struct { fields: HasClosure _ }
        | TagUnionPayload { fields: HasClosure _ }
        | TagUnion (SingleTagStruct { payload: HasClosure _ }) ->
            # Set.single Debug
            Set.empty {}

        Struct { fields: HasNoClosure fields } ->
            allowed = Set.fromList [Clone, Copy, Default, PartialOrd, Ord, PartialEq, Eq, Hash]
            fieldsHelper fields allowed

        TagUnionPayload { fields: HasNoClosure fields } ->
            allowed = Set.fromList [Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash]
            fieldsHelper fields allowed

        TagUnion (SingleTagStruct { payload: HasNoClosure fields }) ->
            allowed = Set.fromList [Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash]
            fieldsHelper fields allowed

        TagUnion (NonRecursive { tags }) ->
            allowed = Set.fromList [Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash]
            tagsHelper tags allowed

        # the `{ tags: tags } situation is due to https://github.com/roc-lang/roc/issues/7167
        TagUnion (Recursive { tags: tags })
        | TagUnion (NullableWrapped { tags: tags }) ->
            allowed = Set.fromList [Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
            tagsHelper tags allowed

        TagUnion (NonNullableUnwrapped { payload })
        | TagUnion (NullableUnwrapped { nonNullPayload: payload }) ->
            Set.fromList [Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
            |> Set.intersection (traitsHelper payload)

        RecursivePointer _ ->
            # TODO: is this correct?
            # encountering a RecursivePointer means we should have already
            # encountered the thing it's pointing to
            # so it wouldn't disqualify it from anything a recursive tag union
            # isn't already disqualified from
            Set.fromList [Clone, PartialEq, Eq, PartialOrd, Ord, Hash]

is64Bit : Architecture -> Bool
is64Bit = \arch ->
    when arch is
        Aarch32 | Wasm32 | X86x32 -> Bool.false
        Aarch64 | X86x64 -> Bool.true

RustSymbol : Str
RustType : Str
Code : Str

# `Debug` is not included here, as it is always implemented.
Trait : [
    Clone,
    Copy,
    Default,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
]

# as received by the roc glue platform
Tags : List { name : Str, payload : [Some TypeId, None] }

# as used in Rust code generation
Variants : List { name : RustSymbol, payload : [None, Single RustType, Multiple { struct : RustType, types : List RustType }], isCopy : Bool }

# MARK: ItemGroup
ItemGroup : [
    Entrypoint Entrypoint,
    Record Record,
    TagUnionPayload TagUnionPayload,
    TagUnion
        [
            Enumeration Enumeration,
            NonRecursive NonRecursive,
            SingleTagStruct SingleTagStruct,
            Recursive Recursive,
        ],
]

Entrypoint : {
    name : RustSymbol,
    number : U64,
    args : List RustType,
    ret : RustType,
}

Record : {
    name : RustSymbol,
    fields : List { name : RustSymbol, type : RustType },
    derives : Set Trait,
}

TagUnionPayload : {
    name : RustSymbol,
    fields : List RustType,
    derives : Set Trait,
}

Enumeration : {
    name : RustSymbol,
    repr : RustType,
    tags : List RustSymbol,
}

NonRecursive : {
    name : RustSymbol,
    rustEnumName : RustSymbol,
    size : U32,
    align : U32,
    discriminant : {
        name : RustSymbol,
        size : U32,
        offset : U32,
    },
    union : {
        name : RustSymbol,
        size : U32,
        align : U32,
    },
    variants : Variants,
    traits : Set Trait,
}

SingleTagStruct : {
    name : RustSymbol,
    tagName : RustSymbol,
    fields : List RustType,
    derives : Set Trait,
}

Recursive : {
    name : RustSymbol,
    unionName : RustSymbol,
    discriminantName : RustSymbol,
    discriminantStorage : [
        Heap {
            offset : U32,
            size: U32,
            allocName : RustType,
        },
        PointerTagging,
    ],
    variants : Variants,
    traits : Set Trait,
}

entrypoints : Types -> List ItemGroup
entrypoints = \types ->
    types
    |> Types.entryPoints
    |> List.mapWithIndex \T name type, number ->
        (args, ret) =
            when Types.shape types type is
                Function func ->
                    nonUnitArgTypes = List.keepOks func.args \arg ->
                        when rustTypeName types arg is
                            "()" -> Err WasUnit
                            nonUnitType -> Ok nonUnitType

                    (
                        nonUnitArgTypes,
                        rustTypeName types func.ret,
                    )

                _ -> ([], rustTypeName types type)
        Entrypoint { name, number: number + 1, args, ret }

tagsToVariants : Types, Tags -> Variants
tagsToVariants = \types, tags ->
    List.map tags \tag ->
        when tag.payload is
            None ->
                {
                    name: tag.name,
                    payload: None,
                    isCopy: Bool.true,
                }

            Some id ->
                name = rustTypeName types id

                getPayloadTypeNames = \list ->
                    List.map list \{ id: payloadId } ->
                        rustTypeName types payloadId

                payload =
                    when Types.shape types id is
                        TagUnionPayload { fields: HasNoClosure list } ->
                            Multiple { struct: name, types: getPayloadTypeNames list }

                        TagUnionPayload { fields: HasClosure list } ->
                            Multiple { struct: name, types: getPayloadTypeNames list }

                        _ -> Single name

                {
                    name: tag.name,
                    payload,
                    isCopy: supportedTraits types id |> Set.contains Copy,
                }

typesToItemGroups : Types -> List ItemGroup
typesToItemGroups = \types ->
    Types.walkShapes types [] \itemGroups, _, type ->
        List.appendIfOk itemGroups (typeToItemGroup types type)

typeToItemGroup : Types, TypeId -> Result ItemGroup [NoItemsNeeded]
typeToItemGroup = \types, type ->
    shape = Types.shape types type
    when shape is
        Struct { name: recordName, fields } ->
            getFields = \{ name, id } -> { name, type: rustTypeName types id }

            recordFields =
                when fields is
                    HasNoClosure list -> List.map list getFields
                    HasClosure list -> List.map list getFields

            Record {
                name: escape recordName,
                fields: recordFields,
                derives: supportedTraits types type,
            }
            |> Ok

        TagUnionPayload { name: recordName, fields: fields } ->
            getFieldType = \{ id } -> rustTypeName types id

            fieldTypes =
                when fields is
                    HasNoClosure list -> List.map list getFieldType
                    HasClosure list -> List.map list getFieldType

            TagUnionPayload {
                name: escape recordName,
                fields: fieldTypes,
                derives: supportedTraits types type,
            }
            |> Ok

        TagUnion (Enumeration { name, tags, size }) ->
            Ok (TagUnion (Enumeration { name: escape name, repr: discriminantRepr size, tags }))

        TagUnion (NonRecursive { name, tags, discriminantSize, discriminantOffset }) ->
            unionAlignment =
                List.walk tags 1 \acc, { payload } ->
                    when payload is
                        Some payloadId -> Num.max acc (Types.alignment types payloadId)
                        None -> acc

            unionSize =
                List.walk tags 1 \acc, { payload } ->
                    when payload is
                        Some payloadId -> Num.max acc (Types.size types payloadId)
                        None -> acc
                |> nextMultipleOf unionAlignment

            {
                name: escape name,
                rustEnumName: "rusty_$(name)",
                size: Types.size types type,
                align: Types.alignment types type,
                discriminant: {
                    name: "discriminant_$(name)",
                    size: discriminantSize,
                    offset: discriminantOffset,
                },
                union: {
                    name: "union_$(name)",
                    size: unionSize,
                    align: unionAlignment,
                },
                variants: tagsToVariants types tags,
                traits: supportedTraits types type,
            }
            |> NonRecursive
            |> TagUnion
            |> Ok

        TagUnion (SingleTagStruct { name, payload, tagName }) ->
            fields =
                rustFieldNames = \list -> List.map list \{ id } -> rustTypeName types id

                when payload is
                    HasNoClosure list -> rustFieldNames list
                    HasClosure list -> rustFieldNames list

            {
                name: escape name,
                tagName,
                fields,
                derives: supportedTraits types type,
            }
            |> SingleTagStruct
            |> TagUnion
            |> Ok

        TagUnion (Recursive { name, tags, discriminantSize, discriminantOffset }) ->
            arch = (Types.target types).architecture

            pointerTagCapacity = if is64Bit arch then 8 else 4

            dbg { arch: Inspect.toStr arch, pointerTagCapacity }

            discriminantStorage =
                if List.len tags > pointerTagCapacity then
                    Heap {
                        size: discriminantSize,
                        offset: discriminantOffset,
                        allocName: "allocation_$(name)",
                    }
                else
                    PointerTagging

            union = Recursive {
                name: escape name,
                discriminantName: "discriminant_$(name)",
                discriminantStorage,
                unionName: "union_$(name)",
                variants: tagsToVariants types tags,
                traits: supportedTraits types type,
            }
            
            Ok (TagUnion union)

        Function { isToplevel } if isToplevel ->
            # taken care of by `entrypoints`
            Err NoItemsNeeded

        Unit
        | Unsized
        | EmptyTagUnion
        | Num _
        | Bool
        | RocResult _ _
        | RocStr
        | RocDict _ _
        | RocSet _
        | RocList _
        | RocBox _ ->
            # these are taken care of by the Roc std library
            # or represented as Rust builtins
            Err NoItemsNeeded

        RecursivePointer _ ->
            # doesn't require a tld
            Err NoItemsNeeded

        _ -> crash "todo: $(Inspect.toStr shape)"

discriminantRepr : U32 -> RustType
discriminantRepr = \bytes ->
    when bytes is
        1 -> "u8"
        2 -> "u16"
        _ -> crash "non-u8/u16 tag union discriminants are not supported at the time of writing"

nextMultipleOf = \lhs, rhs ->
    when lhs % rhs is
        0 -> lhs
        r -> lhs + (rhs - r)

reservedKeywords = Set.fromList [
    "try",
    "abstract",
    "become",
    "box",
    "do",
    "final",
    "macro",
    "override",
    "priv",
    "typeof",
    "unsized",
    "virtual",
    "yield",
    "async",
    "await",
    "dyn",
    "as",
    "break",
    "const",
    "continue",
    "crate",
    "else",
    "enum",
    "extern",
    "false",
    "fn",
    "for",
    "if",
    "impl",
    "in",
    "let",
    "loop",
    "match",
    "mod",
    "move",
    "mut",
    "pub",
    "ref",
    "return",
    "self",
    "Self",
    "static",
    "struct",
    "super",
    "trait",
    "true",
    "type",
    "unsafe",
    "use",
    "where",
    "while",
]

escape : Str -> RustType
escape = \identifier ->
    if Set.contains reservedKeywords identifier then
        # use a raw identifier for this, to prevent a syntax error due to using a reserved keyword.
        # https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html
        # another design would be to add an underscore after it; this is an experiment!
        "r#$(identifier)"
    else
        identifier

rustTypeName : Types, TypeId -> RustType
rustTypeName = \types, type ->
    helper = \id -> rustTypeName types id

    when Types.shape types type is
        RocStr -> "roc_std::RocStr"
        Bool -> "bool"
        Num U8 -> "u8"
        Num I8 -> "i8"
        Num U16 -> "u16"
        Num I16 -> "i16"
        Num U32 -> "u32"
        Num I32 -> "i32"
        Num U64 -> "u64"
        Num I64 -> "i64"
        Num U128 -> "u128"
        Num I128 -> "i128"
        Num F32 -> "f32"
        Num F64 -> "f64"
        Num Dec -> "roc_std::RocDec"
        RocResult a b -> "roc_std::RocResult<$(helper a), $(helper b)>"
        RocList a -> "roc_std::RocList<$(helper a)>"
        RocBox a -> "roc_std::RocBox<$(helper a)>"
        TagUnion (Enumeration { name }) -> escape name
        TagUnion (NonRecursive { name }) -> escape name
        TagUnion (Recursive { name }) -> escape name
        TagUnion (NullableWrapped { name }) -> escape name
        TagUnion (NonNullableUnwrapped { name }) -> escape name
        TagUnion (SingleTagStruct { name }) -> escape name
        TagUnion (NullableUnwrapped { name }) -> escape name
        EmptyTagUnion -> crash "should never happen"
        Struct { name } -> escape name
        Function { functionName } -> escape functionName
        TagUnionPayload { name } -> escape name
        Unit -> "()"
        RecursivePointer content -> rustTypeName types content
        Unsized -> crash "what"
        RocDict _ _ | RocSet _ -> crash "todo"

## indents all lines except the first so multiline substitions play nice in string interpolation
## e.g:
## """
## fn do_stuff() {
##     $(stuff |> indentedBy 1)
## }
## """
indentedBy : Code, U64 -> Code
indentedBy = \code, amount ->
    indent = Str.repeat "\t" amount

    Str.replaceEach code "\n" "\n$(indent)"

## appends code snippet to existing code if applicable
appendIfOk : Str, Result Str * -> Str
appendIfOk = \code, maybeSnippet ->
    when maybeSnippet is
        Ok snippet -> concatCode code snippet
        Err _ -> code

concatCode : Code, Code -> Code
concatCode = \snippetA, snippetB ->
    """
    $(snippetA)

    $(snippetB)
    """

derivesList : Set Trait -> Code
derivesList = \traits ->
    traits
    |> Set.toList
    |> List.map \trait ->
        when trait is
            Clone -> "Clone"
            Copy -> "Copy"
            Default -> "Default"
            PartialEq -> "PartialEq"
            Eq -> "Eq"
            PartialOrd -> "PartialOrd"
            Ord -> "Ord"
            Hash -> "Hash"
    |> Str.joinWith ", "

# MARK: generateItemGroup
generateItemGroup : ItemGroup -> Code
generateItemGroup = \itemGroup ->
    when itemGroup is
        Entrypoint info ->
            entrypoint info

        Record info ->
            record info

        TagUnionPayload info ->
            tagUnionPayload info

        TagUnion (Enumeration info) ->
            enumeration info

        TagUnion (NonRecursive info) ->
            nonRecursive info

        TagUnion (SingleTagStruct info) ->
            singleTagStruct info

        TagUnion (Recursive info) ->
            recursive info

entrypoint : Entrypoint -> Code
entrypoint = \{ name, number, args, ret } ->
    defArgs =
        args
        |> List.mapWithIndex \type, n -> "arg$(Num.toStr n): $(type)"
        |> Str.joinWith ", "

    callArgs =
        args
        |> List.mapWithIndex \_, n -> "arg$(Num.toStr n)"
        |> Str.joinWith ", "

    """
    pub fn $(name)($(defArgs)) -> $(ret) {
        extern "C" {
            fn roc__$(name)_$(Num.toStr number)_exposed_generic(ret: *mut $(ret), $(defArgs));
        }

        let mut ret = core::mem::MaybeUninit::uninit();

        unsafe {
            roc__$(name)_1_exposed_generic(ret.as_mut_ptr(), $(callArgs));

            ret.assume_init()
        }
    }
    """

record : Record -> Code
record = \{ name, fields, derives } ->
    incs =
        fields
        |> List.map \field -> "self.$(field.name).inc();"
        |> Str.joinWith "\n"

    decs =
        fields
        |> List.map \field -> "self.$(field.name).dec();"
        |> Str.joinWith "\n"

    fieldList =
        fields
        |> List.map \field -> "pub $(field.name): $(field.type),"
        |> Str.joinWith "\n"

    refcounted =
        if Set.contains derives Copy then
            "false"
        else
            "true"

    """
    #[repr(C)]
    #[derive(Debug)]
    #[derive($(derivesList derives))]
    pub struct $(name) {
        $(fieldList |> indentedBy 1)
    }

    impl roc_std::RocRefcounted for $(name) {
        fn inc(&mut self) {
            $(incs |> indentedBy 2)
        }

        fn dec(&mut self) {
            $(decs |> indentedBy 2)
        }

        fn is_refcounted() -> bool { $(refcounted) }
    }
    """

tagUnionPayload : TagUnionPayload -> Code
tagUnionPayload = \{ name, fields, derives } ->
    incs =
        fields
        |> List.mapWithIndex \_, i -> "self.$(Num.toStr i).inc();"
        |> Str.joinWith "\n"

    decs =
        fields
        |> List.mapWithIndex \_, i -> "self.$(Num.toStr i).dec();"
        |> Str.joinWith "\n"

    fieldList =
        fields
        |> List.map \fieldType -> "pub $(fieldType),"
        |> Str.joinWith "\n"

    refcounted =
        if Set.contains derives Copy then
            "false"
        else
            "true"

    """
    // this being a tuple struct is fine ABI-wise: https://doc.rust-lang.org/stable/nomicon/other-reprs.html#reprc:~:text=Tuple%20structs%20are%20like%20structs%20with%20regards%20to%20repr(C)%2C%20as%20the%20only%20difference%20from%20a%20struct%20is%20that%20the%20fields%20aren%E2%80%99t%20named.
    #[repr(C)]
    #[derive(Debug)]
    #[derive($(derivesList derives))]
    pub struct $(name)(
        $(fieldList |> indentedBy 1)
    );

    impl roc_std::RocRefcounted for $(name) {
        fn inc(&mut self) {
            $(incs |> indentedBy 2)
        }

        fn dec(&mut self) {
            $(decs |> indentedBy 2)
        }

        fn is_refcounted() -> bool { $(refcounted) }
    }
    """

enumeration : Enumeration -> Code
enumeration = \{ name, repr, tags } ->
    tagList =
        tags
        |> List.map \tag -> "$(tag),"
        |> Str.joinWith "\n"

    matchArms =
        tags
        |> List.map \tag ->
            """
            $(name)::$(tag) => f.write_str("$(name)::$(tag)"),
            """
        |> Str.joinWith "\n"

    """
    #[repr($(repr))]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum $(name) {
        $(tagList |> indentedBy 1)
    }

    impl core::fmt::Debug for $(name) {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            match self {
                $(matchArms |> indentedBy 3)
            }
        }
    }

    roc_refcounted_noop_impl!($(name));
    """

singleTagStruct : SingleTagStruct -> Code
singleTagStruct = \{ name, tagName, fields, derives } ->
    def =
        when fields is
            [] ->
                """
                #[repr(transparent)]
                #[derive($(derivesList derives))]
                pub struct $(name);

                impl $(name) {
                    pub const $(tagName): Self = Self;
                }
                """

            [payload] ->
                """
                #[repr(transparent)]
                #[derive($(derivesList derives))]
                pub struct $(name)(pub $(payload));

                impl $(name) {
                    pub fn $(tagName)(payload: $(payload)) -> Self {
                        Self(payload)
                    }
                }
                """

            payloads ->
                payloadList =
                    payloads
                    |> List.map \payload -> "pub $(payload)"
                    |> Str.joinWith ", "

                init =
                    fields
                    |> List.mapWithIndex \_, i -> "payload.$(Num.toStr i)"
                    |> Str.joinWith ", "

                """
                #[repr(transparent)]
                #[derive($(derivesList derives))]
                /// warning: $(tagName)'s fields have been sorted by alignment;
                /// they may not be in the same order they are in Roc.
                /// if this is undesireable, consider using a record instead.
                pub struct $(name)($(payloadList));

                impl $(name) {
                    pub fn $(tagName)(payload: ($(Str.joinWith fields ", "))) -> Self {
                            Self($(init))
                        }
                    }
                }
                """

    debugSnippet =
        if List.isEmpty fields then
            """
            impl core::fmt::Debug for $(name) {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.write_str("$(name)::$(tagName)")
                }
            }
            """
        else
            fieldBuilders =
                fields
                |> List.mapWithIndex \_, i -> ".field(&self.$(Num.toStr i))"
                |> Str.joinWith "\n"

            """
            impl core::fmt::Debug for $(name) {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_tuple("$(name)::$(tagName)")
                        $(fieldBuilders |> indentedBy 3)
                        .finish()
                }
            }
            """

    refcountSnippet =
        if Set.contains derives Copy then
            """
            roc_refcounted_noop_impl!($(name));
            """
        else
            incs =
                fields
                |> List.mapWithIndex \_, i -> "self.$(Num.toStr i).inc();"
                |> Str.joinWith "\n"

            decs =
                fields
                |> List.mapWithIndex \_, i -> "self.$(Num.toStr i).dec();"
                |> Str.joinWith "\n"

            """
            impl roc_std::RocRefcounted for $(name) {
                fn inc(&mut self) {
                    $(incs |> indentedBy 2)
                }

                fn dec(&mut self) {
                    $(decs |> indentedBy 2)
                }

                fn is_refcounted() -> bool { true }
            }
            """

    def
    |> concatCode debugSnippet
    |> concatCode refcountSnippet

recursive : Recursive -> Code
recursive = \info ->
    { name, variants, unionName, discriminantName, discriminantStorage } = info

    variantNames =
        variants
        |> List.map .name
        |> Str.joinWith ", "

    tagList =
        variants
        |> List.mapWithIndex \variant, i -> "$(variant.name) = $(Num.toStr i),"
        |> Str.joinWith "\n"

    unionVariantList =
        variants
        |> List.map \variant ->
            payload =
                when variant.payload is
                    None -> "()"
                    Single type | Multiple { struct: type } -> type

            if variant.isCopy then
                "$(variant.name): $(payload),"
            else
                "$(variant.name): core::mem::ManuallyDrop<$(payload)>,"
        |> Str.joinWith "\n"
    
    common =
        when discriminantStorage is
            PointerTagging ->
                pointerTagMask = if List.len variants > 4 then "0b111usize" else "0b11usize"

                """
                #[repr(transparent)]
                pub struct $(name) {
                    // points to a `$(unionName)`
                    tagged_ptr: usize,
                }

                // no repr(C) on this cause this is never used in interop
                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
                pub enum $(discriminantName) {
                    $(tagList |> indentedBy 1)
                }

                #[repr(C)]
                pub union $(unionName) {
                    $(unionVariantList |> indentedBy 1)
                }

                impl $(name) {
                    pub fn discriminant(&self) -> $(discriminantName) {
                        let discriminants = {
                            use $(discriminantName)::*;

                            [$(variantNames)]
                        };

                        discriminants[self.tagged_ptr & $(pointerTagMask)]
                    }

                    pub fn union_ptr(&self) -> *mut $(unionName) {
                        (self.tagged_ptr & !$(pointerTagMask)) as *mut _
                    }
                }

                // we're using a leaked RocBox allocation to store this union,
                // and RocBox requires RocRefcounted to be implemented on its child type.
                // however, since refcounting is handled through the `$(name)` type, these functions
                // will never actually be called, so they can be left blank.
                // TODO: is there a way to avoid this dummy implementation?
                $(dummyRefcountImpl unionName)
                """
            
            Heap { allocName } ->
                """
                #[repr(transparent)]
                pub struct $(name) {
                    ptr: *mut $(allocName),
                }

                #[repr(C)]
                struct $(allocName) {
                    payload: $(unionName),
                    discriminant: $(discriminantName),
                }

                #[repr(C)]
                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
                pub enum $(discriminantName) {
                    $(tagList |> indentedBy 1)
                }

                #[repr(C)]
                pub union $(unionName) {
                    $(unionVariantList |> indentedBy 1)
                }

                impl $(name) {
                    pub fn discriminant(&self) -> $(discriminantName) {
                        unsafe { (*self.ptr).discriminant }
                    }

                    pub fn union_ptr(&self) -> *mut $(unionName) {
                        unsafe { &mut (*self.ptr).payload }
                    }
                }

                // we're using a leaked RocBox allocation to store this union,
                // and RocBox requires RocRefcounted to be implemented on its child type.
                // however, since refcounting is handled through the `$(name)` type, these functions
                // will never actually be called, so they can be left blank.
                // TODO: is there a way to avoid this dummy implementation?
                $(dummyRefcountImpl allocName)
                """



    common
    |> concatCode (recursiveConstructors info)
    |> concatCode (recursiveDebugImpl info)
    |> concatCode (recursiveRefcountingImpl info)
    |> appendIfOk (recursiveCloneImpl info)
    |> appendIfOk (recursiveDropImpl info)
    |> appendIfOk (recursiveOrderingImpl info)
    |> appendIfOk (recursiveEqualityImpl info)
    |> appendIfOk (recursiveHashImpl info)

recursiveConstructors : Recursive -> Code
recursiveConstructors = \{ name, variants, discriminantName, discriminantStorage, unionName } ->
    variantMethods = \variant ->
        variantCheck =
            """
            pub fn is_$(variant.name)(&self) -> bool {
                matches!(self.discriminant(), $(discriminantName)::$(variant.name))
            }
            """

        constructor =
            payloadValue =
                if variant.isCopy then "payload" else "core::mem::ManuallyDrop::new(payload)"
            
            when variant.payload is
                None -> crash "this kind of tag union should have payloads on every tag"
                Single type ->
                    when discriminantStorage is
                        PointerTagging ->
                            """
                            pub fn $(variant.name)(payload: $(type)) -> Self {
                                let payload_union = $(unionName) { $(variant.name): $(payloadValue) };

                                let allocation_ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(payload_union)) };

                                let tagged_ptr = (allocation_ptr as usize) | ($(discriminantName)::$(variant.name) as usize);

                                Self { tagged_ptr }
                            }
                            """
                        
                        Heap { allocName } ->
                            """
                            pub fn $(variant.name)(payload: $(type)) -> Self {
                                let tagged_union = $(allocName) {
                                    discriminant: $(discriminantName)::$(variant.name),
                                    payload: $(unionName) { $(variant.name): $(payloadValue) },
                                };

                                let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(tagged_union)) };

                                Self { ptr }
                            }
                            """

                Multiple { struct, types } ->
                    argList =
                        types
                        |> List.mapWithIndex \type, i -> "p$(Num.toStr i): $(type)"
                        |> Str.joinWith ", "

                    initList =
                        types
                        |> List.mapWithIndex \_, i -> "p$(Num.toStr i)"
                        |> Str.joinWith ", "

                    when discriminantStorage is
                        PointerTagging ->
                            """
                            pub fn $(variant.name)_from_payload_struct(payload: $(struct)) -> Self {
                                let payload_union = $(unionName) { $(variant.name): $(payloadValue) };

                                let allocation_ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(payload_union)) };

                                let tagged_ptr = (allocation_ptr as usize) | ($(discriminantName)::$(variant.name) as usize);

                                Self { tagged_ptr }
                            }

                            pub fn $(variant.name)($(argList)) -> Self {
                                Self::$(variant.name)_from_payload_struct($(struct)($(initList)))
                            }
                            """
                        
                        Heap { allocName } ->
                            """
                            pub fn $(variant.name)_from_payload_struct(payload: $(struct)) -> Self {
                                let tagged_union = $(allocName) {
                                    discriminant: $(discriminantName)::$(variant.name),
                                    payload: $(unionName) { $(variant.name): $(payloadValue) },
                                };

                                let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(tagged_union)) };

                                Self { ptr }
                            }

                            pub fn $(variant.name)($(argList)) -> Self {
                                Self::$(variant.name)_from_payload_struct($(struct)($(initList)))
                            }
                            """


        concatCode variantCheck constructor

    methods =
        variants
        |> List.map variantMethods
        |> Str.joinWith "\n\n"

    """
    impl $(name) {
        $(methods |> indentedBy 1)
    }
    """

recursiveDebugImpl : Recursive -> Code
recursiveDebugImpl = \{ name, discriminantName, variants } ->
    matchArms =
        variants
        |> List.map \variant ->
            when variant.payload is
                None ->
                    """
                    $(discriminantName)::$(variant.name) =>
                        f.write_str("$(name)::$(variant.name)"),
                    """

                Single payload ->
                    """
                    $(discriminantName)::$(variant.name) => {
                        let payload: &$(payload) = &(*self.union_ptr()).$(variant.name);
                        f.debug_tuple("$(name)::$(variant.name)")
                            .field(payload)
                            .finish()
                    }
                    """

                Multiple { struct, types } ->
                    fieldBuilders =
                        types
                        |> List.mapWithIndex \_, i -> ".field(&payload.$(Num.toStr i))"
                        |> Str.joinWith "\n"

                    """
                    $(discriminantName)::$(variant.name) => {
                        let payload: &$(struct) = &((*self.union_ptr()).$(variant.name));
                        f.debug_tuple("$(name)::$(variant.name)")
                            $(fieldBuilders |> indentedBy 2)
                            .finish()
                    }
                    """
        |> Str.joinWith "\n\n"

    """
    impl core::fmt::Debug for $(name) {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            unsafe {
                match self.discriminant() {
                    $(matchArms |> indentedBy 4)
                }
            }
        }
    }
    """

recursiveRefcountingImpl : Recursive -> Code
recursiveRefcountingImpl = \{ name, discriminantName, variants, traits } ->
    if Set.contains traits Copy then
        """
        roc_refcounted_noop_impl!($(name));
        """
    else
        matchArms = \incOrDec ->
            variants
            |> List.map \variant ->
                if variant.isCopy then
                    """
                    $(discriminantName)::$(variant.name) =>
                        (*self.union_ptr()).$(variant.name).$(incOrDec)(),
                    """
                else
                    """
                    $(discriminantName)::$(variant.name) =>
                        (*(*self.union_ptr()).$(variant.name)).$(incOrDec)(),
                    """
            |> Str.joinWith "\n\n"

        """
        impl roc_std::RocRefcounted for $(name) {
            fn inc(&mut self) {
                unsafe {
                    match self.discriminant() {
                        $(matchArms "inc" |> indentedBy 3)
                    }
                }
            }

            fn dec(&mut self) {
                unsafe {
                    match self.discriminant() {
                        $(matchArms "dec" |> indentedBy 3)
                    }
                }
            }

            fn is_refcounted() -> bool { true }
        }
        """

dummyRefcountImpl : RustSymbol -> Code
dummyRefcountImpl = \name ->
    """
    impl roc_std::RocRefcounted for $(name) {
        fn inc(&mut self) { unimplemented!(); }
        fn dec(&mut self) { unimplemented!(); }
        fn is_refcounted() -> bool { unimplemented!(); }
    }
    """

recursiveCloneImpl : Recursive -> Result Code [NotApplicable]
recursiveCloneImpl = \{ name, discriminantName, variants, traits } ->
    if Set.contains traits Clone then
        matchArms =
            variants
            |> List.map \variant ->
                constructorName =
                    # at time of writing, removing this indirection causes the roc compiler to crash on build.
                    # TODO: make a minimal reproduction, if it still exists
                    payload = variant.payload
                    when payload is
                        Multiple _ -> "Self::$(variant.name)_from_payload_struct"
                        _ -> "Self::$(variant.name)"

                clonedPayload =
                    if variant.isCopy then
                        "(*self.union_ptr()).$(variant.name)"
                    else
                        "(*(*self.union_ptr()).$(variant.name)).clone()"

                """
                $(discriminantName)::$(variant.name) =>
                    $(constructorName)(
                        $(clonedPayload)
                    ),
                """
            |> Str.joinWith "\n\n"

        """
        impl core::clone::Clone for $(name) {
            fn clone(&self) -> Self {
                unsafe {
                    match self.discriminant() {
                        $(matchArms |> indentedBy 4)
                    }
                }
            }
        }
        """
        |> Ok
    else
        Err NotApplicable

recursiveDropImpl : Recursive -> Result Code [NotApplicable]
recursiveDropImpl = \{ name, variants, discriminantName, traits } ->
    if Set.contains traits Copy then
        Err NotApplicable
    else
        matchArms =
            variants
            |> List.map \variant ->
                if variant.isCopy then
                    "$(discriminantName)::$(variant.name) => {},"
                else
                    """
                    $(discriminantName)::$(variant.name) => unsafe {
                        core::mem::ManuallyDrop::drop(&mut (*self.union_ptr()).$(variant.name));
                    },
                    """
            |> Str.joinWith "\n"

        """
        impl Drop for $(name) {
            fn drop(&mut self) {
                // manually drop the payloads if applicable
                match self.discriminant() {
                    $(matchArms |> indentedBy 3)
                }
            }
        }
        """
        |> Ok

recursiveOrderingImpl : Recursive -> Result Code [NotApplicable]
recursiveOrderingImpl = \{ name, discriminantName, variants, traits } ->
    if Set.contains traits Ord then
        matchArms =
            variants
            |> List.map \variant ->
                "$(discriminantName)::$(variant.name) => (*self.union_ptr()).$(variant.name).cmp(&(*other.union_ptr()).$(variant.name)),"
            |> Str.joinWith "\n"

        """
        impl core::cmp::Ord for $(name) {
            fn cmp(&self, other: &Self) -> core::cmp::Ordering {
                match self.discriminant().cmp(&other.discriminant()) {
                    core::cmp::Ordering::Less => core::cmp::Ordering::Less,
                    core::cmp::Ordering::Greater => core::cmp::Ordering::Greater,
                    core::cmp::Ordering::Equal =>
                        // SAFETY: self.discriminant() checked below, other.discriminant() checked by virtue of them being checked to be equal above
                        unsafe {
                            match self.discriminant() {
                                $(matchArms |> indentedBy 6)
                            }
                        },
                }
            }
        }

        impl core::cmp::PartialOrd for $(name) {
            fn partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering> {
                core::option::Option::Some(self.cmp(other))
            }
        }
        """
        |> Ok
    else if Set.contains traits PartialOrd then
        matchArms =
            variants
            |> List.map \variant ->
                "$(discriminantName)::$(variant.name) => (*self.union_ptr()).$(variant.name).partial_cmp(&(*other.union_ptr()).$(variant.name)),"
            |> Str.joinWith "\n"

        """
        impl core::cmp::PartialOrd for $(name) {
            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
                match self.discriminant().cmp(&other.discriminant()) {
                    core::cmp::Ordering::Less => Option::Some(core::cmp::Ordering::Less),
                    core::cmp::Ordering::Greater => Option::Some(core::cmp::Ordering::Greater),
                    core::cmp::Ordering::Equal =>
                        // SAFETY: self.discriminant() checked below, other.discriminant() checked in virtue of them being checked to be equal above
                        unsafe {
                            match self.discriminant() {
                                $(matchArms |> indentedBy 6)
                            }
                        },
                }
            }
        }
        """
        |> Ok
    else
        Err NotApplicable

recursiveEqualityImpl : Recursive -> Result Code [NotApplicable]
recursiveEqualityImpl = \{ name, variants, discriminantName, traits } ->
    if Set.contains traits PartialEq then
        matchArms =
            variants
            |> List.map \variant ->
                "$(discriminantName)::$(variant.name) => (*self.union_ptr()).$(variant.name) == (*other.union_ptr()).$(variant.name),"
            |> Str.joinWith "\n"

        partialEq =
            """
            impl PartialEq for $(name) {
                fn eq(&self, other: &Self) -> bool {
                    if self.discriminant() != other.discriminant() {
                        return false;
                    }

                    // SAFETY: `self.discriminant()` is matched upon, `other.discriminant()` was checked above
                    unsafe {
                        match self.discriminant() {
                            $(matchArms |> indentedBy 4)
                        }
                    }
                }
            }
            """

        if Set.contains traits Eq then
            Ok (concatCode partialEq "impl Eq for $(name) {}")
        else
            Ok partialEq
    else
        Err NotApplicable

recursiveHashImpl : Recursive -> Result Code [NotApplicable]
recursiveHashImpl = \{ name, traits, variants, discriminantName } ->
    if Set.contains traits Hash then
        matchArms =
            variants
            |> List.map \variant -> "$(discriminantName)::$(variant.name) => (*self.union_ptr()).$(variant.name).hash(state),"
            |> Str.joinWith "\n\n"

        """
        impl core::hash::Hash for $(name) {
            fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
                // TODO: this hashes the pointer, mirroring what `Box` does. Is this acceptable?
                self.discriminant().hash(state);

                unsafe {
                    match self.discriminant() {
                        $(matchArms |> indentedBy 4)
                    }
                }
            }
        }
        """
        |> Ok
    else
        Err NotApplicable

nonRecursive : NonRecursive -> Code
nonRecursive = \info ->
    { name, size, align, discriminant, union, variants } = info

    tagList =
        variants
        |> List.map .name
        |> Str.joinWith ",\n"

    unionVariantList =
        variants
        |> List.map \variant ->
            payload =
                when variant.payload is
                    None -> "()"
                    Single type -> type
                    Multiple { struct } -> struct

            if variant.isCopy then
                "$(variant.name): $(payload),"
            else
                "$(variant.name): core::mem::ManuallyDrop<$(payload)>,"
        |> Str.joinWith "\n"

    """
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[repr($(discriminantRepr discriminant.size))]
    pub enum $(discriminant.name) {
        $(tagList |> indentedBy 1)
    }

    #[repr(C, align($(union.align |> Num.toStr)))]
    pub union $(union.name) {
        $(unionVariantList |> indentedBy 1)
    }

    // This will break when #7171 is fixed:
    // https://github.com/roc-lang/roc/issues/7171
    #[repr(C)]
    pub struct $(name) {
        payload: $(union.name),
        discriminant: $(discriminant.name),
    }

    const _SIZE_CHECK_$(union.name): () = assert!(core::mem::size_of::<$(union.name)>() == $(Num.toStr union.size));
    const _ALIGN_CHECK_$(union.name): () = assert!(core::mem::align_of::<$(union.name)>() == $(Num.toStr union.align));

    const _SIZE_CHECK_$(name): () = assert!(core::mem::size_of::<$(name)>() == $(Num.toStr size));
    const _ALIGN_CHECK_$(name): () = assert!(core::mem::align_of::<$(name)>() == $(Num.toStr align));

    impl $(name) {
        /// Returns which variant this tag union holds. Note that this never includes a payload!
        pub fn discriminant(&self) -> $(discriminant.name) {
            self.discriminant
        }
    }
    """
    |> concatCode (nonRecursiveVariantMethods info)
    |> concatCode (nonRecursiveRefcountImpl info)
    |> concatCode (nonRecursiveRustEnumImpl info)
    |> concatCode (nonRecursiveDebugImpl info)
    |> appendIfOk (nonRecursiveCloneImpl info)
    |> appendIfOk (nonRecursiveCopyImpl info)
    |> appendIfOk (nonRecursiveDropImpl info)
    |> appendIfOk (nonRecursivePartialEqImpl info)
    |> appendIfOk (nonRecursiveEqImpl info)
    |> appendIfOk (nonRecursiveCmpImpl info)
    |> appendIfOk (nonRecursiveHashSnippet info)

nonRecursiveVariantMethods : NonRecursive -> Code
nonRecursiveVariantMethods = \{ name, variants, discriminant, union } ->
    variants
    |> List.map \variant ->
        # TODO: split these into appropriate unsafe "_unchecked" methods and checked and panic-y versions
        # TODO: maybe change the `borrow_*()` method name to `copy_*()` if the payload is Copy? seems more intuitive
        variantCheck =
            """
            pub fn is_$(variant.name)(&self) -> bool {
                matches!(self.discriminant, $(discriminant.name)::$(variant.name))
            }
            """

        constructor =
            when variant.payload is
                None ->
                    """
                    pub fn $(variant.name)() -> Self {
                        Self {
                            discriminant: $(discriminant.name)::$(variant.name),
                            payload: $(union.name) {
                                $(variant.name): (),
                            },
                        }
                    }
                    """

                Single type ->
                    payloadValue =
                        if variant.isCopy then "payload" else "core::mem::ManuallyDrop::new(payload)"

                    """
                    pub fn $(variant.name)(payload: $(type)) -> Self {
                        Self {
                            discriminant: $(discriminant.name)::$(variant.name),
                            payload: $(union.name) {
                                $(variant.name): $(payloadValue),
                            },
                        }
                    }
                    """

                Multiple { struct, types } ->
                    argList =
                        types
                        |> List.mapWithIndex \type, i -> "p$(Num.toStr i): $(type)"
                        |> Str.joinWith ", "

                    initList =
                        types
                        |> List.mapWithIndex \_, i -> "p$(Num.toStr i)"
                        |> Str.joinWith ", "

                    payloadValue =
                        if variant.isCopy then
                            "$(struct)($(initList))"
                        else
                            "core::mem::ManuallyDrop::new($(struct)($(initList)))"

                    """
                    pub fn $(variant.name)($(argList)) -> Self {
                        Self {
                            discriminant: $(discriminant.name)::$(variant.name),
                            payload: $(union.name) {
                                $(variant.name): $(payloadValue),
                            }
                        }
                    }
                    """

        borrowMut =
            when variant.payload is
                None -> Err NotApplicable
                Single payload | Multiple { struct: payload } ->
                    Ok
                        """
                        pub fn borrow_mut_$(variant.name)(&mut self) -> &mut $(payload) {
                            debug_assert_eq!(self.discriminant, $(discriminant.name)::$(variant.name));
                            unsafe { &mut self.payload.$(variant.name) }
                        }
                        """

        borrow =
            when variant.payload is
                None -> Err NotApplicable
                Single payload | Multiple { struct: payload } if variant.isCopy ->
                    Ok
                        """
                        pub fn borrow_$(variant.name)(&mut self) -> $(payload) {
                            debug_assert_eq!(self.discriminant, $(discriminant.name)::$(variant.name));
                            unsafe { self.payload.$(variant.name) }
                        }
                        """

                Single payload | Multiple { struct: payload } ->
                    Ok
                        """
                        pub fn borrow_$(variant.name)(&mut self) -> &$(payload) {
                            debug_assert_eq!(self.discriminant, $(discriminant.name)::$(variant.name));
                            unsafe { &self.payload.$(variant.name) }
                        }
                        """

        unwrap =
            when variant.payload is
                None -> Err NotApplicable
                Single payload | Multiple { struct: payload } if variant.isCopy ->
                    Ok
                        """
                        pub fn unwrap_$(variant.name)(self) -> $(payload) {
                            debug_assert_eq!(self.discriminant, $(discriminant.name)::$(variant.name));
                            unsafe { self.payload.$(variant.name) }
                        }
                        """

                Single payload | Multiple { struct: payload } ->
                    Ok
                        """
                        pub fn unwrap_$(variant.name)(mut self) -> $(payload) {
                            debug_assert_eq!(self.discriminant, $(discriminant.name)::$(variant.name));
                            unsafe { core::mem::ManuallyDrop::take(&mut self.payload.$(variant.name)) }
                        }
                        """

        variantCheck
        |> concatCode constructor
        |> appendIfOk unwrap
        |> appendIfOk borrow
        |> appendIfOk borrowMut
    |> Str.joinWith "\n\n"
    |> \methods ->
        """
        impl $(name) {
            $(methods |> indentedBy 1)
        }
        """

nonRecursiveDebugImpl : NonRecursive -> Code
nonRecursiveDebugImpl = \{ name, variants, discriminant } ->
    debugMatchArms =
        variants
        |> List.map \variant ->
            # # TODO: maybe change the tests to allow this cause it looks better
            # if variant.payload == "()" then
            #     """
            #     $(discriminant.name)::$(variant.name) => f.write_str("$(name)::$(variant.name)"),
            #     """
            # else
            #     """
            #     $(discriminant.name)::$(variant.name) => {
            #         let payload: &$(variant.payload) = &self.payload.$(variant.name);
            #         f.debug_tuple("$(name)::$(variant.name)").field(payload).finish()
            #     }
            #     """
            payloadType =
                when variant.payload is
                    None -> "()"
                    Single payload | Multiple { struct: payload } -> payload
            """
            $(discriminant.name)::$(variant.name) => {
                let payload: &$(payloadType) = &self.payload.$(variant.name);
                f.debug_tuple("$(name)::$(variant.name)").field(payload).finish()
            }
            """
        |> Str.joinWith "\n\n"

    discriminantDebugMatchArms =
        variants
        |> List.map \variant ->
            """
            $(discriminant.name)::$(variant.name) => f.write_str("$(discriminant.name)::$(variant.name)"),
            """
        |> Str.joinWith "\n"

    """
    impl core::fmt::Debug for $(name) {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            unsafe {
                match self.discriminant {
                    $(debugMatchArms |> indentedBy 4)
                }
            }
        }
    }

    impl core::fmt::Debug for $(discriminant.name) {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            match self {
                $(discriminantDebugMatchArms |> indentedBy 4)
            }
        }
    }
    """

nonRecursiveRefcountImpl : NonRecursive -> Code
nonRecursiveRefcountImpl = \{ name, variants, discriminant, traits } ->
    refcountMatchArms = \methodName ->
        variants
        |> List.map \variant ->
            if variant.isCopy then
                "$(discriminant.name)::$(variant.name) => self.payload.$(variant.name).$(methodName)(),"
            else
                # this has to be explicitly dereferenced, because the compiler is scared that an implicit
                # DerefMut will cause us to accidentally call Drop when we didn't intend to. Decrementing the
                # refcount may technically cause the underlying data to be dropped, but at that point the union
                # needs not be valid anymore anyway, as it means we're no longer using it.
                "$(discriminant.name)::$(variant.name) => (*self.payload.$(variant.name)).$(methodName)(),"
        |> Str.joinWith "\n"

    """
    impl roc_std::RocRefcounted for $(name) {
        fn inc(&mut self) {
            unsafe {
                match self.discriminant {
                    $(refcountMatchArms "inc" |> indentedBy 4)
                }
            }
        }

        fn dec(&mut self) {
            unsafe {
                match self.discriminant {
                    $(refcountMatchArms "dec" |> indentedBy 4)
                }
            }
        }

        fn is_refcounted() -> bool { $(if Set.contains traits Copy then "false" else "true") }
    }
    """

nonRecursiveRustEnumImpl : NonRecursive -> Code
nonRecursiveRustEnumImpl = \{ name, rustEnumName, discriminant, union, variants, traits } ->
    rustEnumList =
        variants
        |> List.map \variant ->
            when variant.payload is
                None -> "$(variant.name),"
                Single type | Multiple { struct: type } ->
                    "$(variant.name)($(type)),"
        |> Str.joinWith "\n"

    fromRocMatchArms =
        variants
        |> List.map \variant ->
            if variant.payload == None then
                """
                $(discriminant.name)::$(variant.name) =>
                    $(rustEnumName)::$(variant.name),
                """
            else if variant.isCopy then
                """
                $(discriminant.name)::$(variant.name) =>
                    unsafe { $(rustEnumName)::$(variant.name)(item.payload.$(variant.name)) },
                """
            else
                """
                $(discriminant.name)::$(variant.name) =>
                    unsafe { $(rustEnumName)::$(variant.name)(core::mem::ManuallyDrop::take(&mut item.payload.$(variant.name))) },
                """
        |> Str.joinWith "\n"

    """
    /// a rust enum equivalent of $(name).
    /// safer/more convenient to work with, but does require rearranging some memory to get.
    #[repr(C)]
    #[derive(Debug)]
    #[derive($(derivesList traits))]
    pub enum $(rustEnumName) {
        $(rustEnumList |> indentedBy 1)
    }

    impl From<$(name)> for $(rustEnumName) {
        fn from(mut item: $(name)) -> Self {
            // TODO: see if this can be done by rearranging memory like the other conversion without crashing mysteriously
            match item.discriminant {
                $(fromRocMatchArms |> indentedBy 3)
            }

            // #[repr(C)]
            // struct Temp {
            //     discriminant: $(discriminant.name),
            //     payload: $(union.name),
            // }
            // 
            // #[repr(C)]
            // struct Temp2 {
            //     payload: $(union.name),
            //     discriminant: $(discriminant.name),
            // }
            // 
            // // println!("DEBUG1: {:?}", item.discriminant);
            // 
            // let without_drop = unsafe { core::mem::transmute::<$(name), Temp2>(item) };
            // 
            // // SAFETY: moving non-copy fields out of `item` is normally disallowed,
            // // since we'd be circumventing the destructor. Since we mem::forget `item` after this,
            // // and the newly created $(rustEnumName) is put in charge of running the destructors afterwards, this is safe.
            // let with_swapped_fields = Temp {
            //     discriminant: without_drop.discriminant,
            //     payload: without_drop.payload,
            // };
            // 
            // // SAFETY: Temp has the same layout as a #[repr(C)] enum, which is what $(rustEnumName) is:
            // // https://doc.rust-lang.org/reference/type-layout.html#reprc-enums-with-fields
            // unsafe { core::mem::transmute::<Temp, $(rustEnumName)>(with_swapped_fields) }
        }
    }

    impl From<$(rustEnumName)> for $(name) {
        fn from(item: $(rustEnumName)) -> Self {
            #[repr(C)]
            struct Temp {
                discriminant: $(discriminant.name),
                payload: $(union.name),
            }

            // SAFETY: Temp has the same layout as a #[repr(C)] enum, which is what $(rustEnumName) is:
            // https://doc.rust-lang.org/reference/type-layout.html#reprc-enums-with-fields
            let decomposed = unsafe { core::mem::transmute::<$(rustEnumName), Temp>(item) };

            $(name) {
                payload: decomposed.payload,
                discriminant: decomposed.discriminant,
            }
        }
    }
    """

nonRecursiveCopyImpl : NonRecursive -> Result Code [NotApplicable]
nonRecursiveCopyImpl = \{ name, traits } ->
    if Set.contains traits Copy then
        Ok "impl Copy for $(name) {}"
    else
        Err NotApplicable

nonRecursiveCloneImpl : NonRecursive -> Result Code [NotApplicable]
nonRecursiveCloneImpl = \{ traits, name, variants, discriminant, union } ->
    if Set.contains traits Clone then
        matchArms =
            variants
            |> List.map \variant ->
                if variant.isCopy then
                    """
                    $(discriminant.name)::$(variant.name) => $(union.name) {
                        $(variant.name): self.payload.$(variant.name),
                    },
                    """
                else
                    """
                    $(discriminant.name)::$(variant.name) => $(union.name) {
                        $(variant.name): self.payload.$(variant.name).clone(),
                    },
                    """
            |> Str.joinWith "\n\n"

        """
        impl core::clone::Clone for $(name) {
            fn clone(&self) -> Self {
                use $(discriminant.name)::*;

                let payload = unsafe {
                    match self.discriminant {
                        $(matchArms |> indentedBy 4)
                    }
                };

                Self {
                    discriminant: self.discriminant,
                    payload,
                }
            }
        }
        """
        |> Ok
    else
        Err NotApplicable

nonRecursiveDropImpl : NonRecursive -> Result Code [NotApplicable]
nonRecursiveDropImpl = \{ name, variants, discriminant, traits } ->
    if Set.contains traits Copy then
        Err NotApplicable
    else
        matchArms =
            variants
            |> List.map \variant ->
                if variant.isCopy then
                    "$(discriminant.name)::$(variant.name) => {},"
                else
                    """
                    $(discriminant.name)::$(variant.name) => unsafe {
                        core::mem::ManuallyDrop::drop(&mut self.payload.$(variant.name));
                    },
                    """
            |> Str.joinWith "\n"

        """
        impl Drop for $(name) {
            fn drop(&mut self) {
                // manually drop the payloads if applicable
                match self.discriminant() {
                    $(matchArms |> indentedBy 3)
                }
            }
        }
        """
        |> Ok

nonRecursivePartialEqImpl : NonRecursive -> Result Code [NotApplicable]
nonRecursivePartialEqImpl = \{ name, variants, discriminant, traits } ->
    if Set.contains traits PartialEq then
        matchArms =
            variants
            |> List.map \variant ->
                """
                    $(discriminant.name)::$(variant.name) =>
                        self.payload.$(variant.name) == other.payload.$(variant.name),
                """
            |> Str.joinWith "\n\n"

        """
        impl PartialEq for $(name) {
            fn eq(&self, other: &Self) -> bool {
                if self.discriminant != other.discriminant {
                    return false;
                }

                // SAFETY: `self.discriminant` is matched upon, `other.discriminant` was checked above
                unsafe {
                    match self.discriminant {
                        $(matchArms |> indentedBy 4)
                    }
                }
            }
        }
        """
        |> Ok
    else
        Err NotApplicable

nonRecursiveEqImpl : NonRecursive -> Result Code [NotApplicable]
nonRecursiveEqImpl = \{ name, traits } ->
    if Set.contains traits Eq then
        Ok "impl Eq for $(name) {}"
    else
        Err NotApplicable

nonRecursiveCmpImpl : NonRecursive -> Result Code [NotApplicable]
nonRecursiveCmpImpl = \{ name, variants, discriminant, traits } ->
    if Set.contains traits Ord then
        matchArms =
            variants
            |> List.map \variant ->
                "$(discriminant.name)::$(variant.name) => self.payload.$(variant.name).cmp(&other.payload.$(variant.name)),"
            |> Str.joinWith "\n"

        """
        impl core::cmp::Ord for $(name) {
            fn cmp(&self, other: &Self) -> core::cmp::Ordering {
                match self.discriminant.cmp(&other.discriminant) {
                    core::cmp::Ordering::Less => core::cmp::Ordering::Less,
                    core::cmp::Ordering::Greater => core::cmp::Ordering::Greater,
                    core::cmp::Ordering::Equal =>
                        // SAFETY: self.discriminant checked below, other.discriminant checked by virtue of them being checked to be equal above
                        unsafe {
                            match self.discriminant {
                                $(matchArms |> indentedBy 6)
                            }
                        },
                }
            }
        }

        impl core::cmp::PartialOrd for $(name) {
            fn partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering> {
                core::option::Option::Some(self.cmp(other))
            }
        }
        """
        |> Ok
    else if Set.contains traits PartialOrd then
        matchArms =
            variants
            |> List.map \variant ->
                "$(discriminant.name)::$(variant.name) => self.payload.$(variant.name).partial_cmp(&other.payload.$(variant.name)),"
            |> Str.joinWith "\n"

        """
        impl core::cmp::PartialOrd for $(name) {
            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
                match self.discriminant.cmp(&other.discriminant) {
                    core::cmp::Ordering::Less => Option::Some(core::cmp::Ordering::Less),
                    core::cmp::Ordering::Greater => Option::Some(core::cmp::Ordering::Greater),
                    core::cmp::Ordering::Equal =>
                        // SAFETY: self.discriminant checked below, other.discriminant checked in virtue of them being checked to be equal above
                        unsafe {
                            match self.discriminant {
                                $(matchArms |> indentedBy 6)
                            }
                        },
                }
            }
        }
        """
        |> Ok
    else
        Err NotApplicable

nonRecursiveHashSnippet : NonRecursive -> Result Code [NotApplicable]
nonRecursiveHashSnippet = \{ name, discriminant, variants, traits } ->
    if Set.contains traits Hash then
        matchArms =
            variants
            |> List.map \variant ->
                "$(discriminant.name)::$(variant.name) => self.payload.$(variant.name).hash(state),"
            |> Str.joinWith "\n"

        """
        impl core::hash::Hash for $(name) {
            fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
                unsafe {
                    match self.discriminant {
                        $(matchArms |> indentedBy 4)
                    }
                }
            }
        }
        """
        |> Ok
    else
        Err NotApplicable
